(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.tracardi = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*
// set
cookie('test', 'a')

// complex set - cookie(name, value, ttl, path, domain, secure)
cookie('test', 'a', 60*60*24, '/api', '*.example.com', true)

// get
cookie('test')

// destroy
cookie('test', '', -1)
*/
function cookie(name, value, ttl, path, domain, secure) {
  if (typeof window === 'undefined') return;
  /* Set values */

  if (arguments.length > 1) {
    // eslint-disable-next-line no-return-assign
    return document.cookie = name + '=' + encodeURIComponent(value) + ( // eslint-disable-next-line operator-linebreak
    !ttl ? '' : // Has TTL set expiration on cookie
    '; expires=' + new Date(+new Date() + ttl * 1000).toUTCString() + ( // If path set path
    !path ? '' : '; path=' + path) + ( // If domain set domain
    !domain ? '' : '; domain=' + domain) + ( // If secure set secure
    !secure ? '' : '; secure'));
  }

  return decodeURIComponent((('; ' + document.cookie).split('; ' + name + '=')[1] || '').split(';')[0]);
}

function hasCookieSupport() {
  try {
    var key = '_c_'; // Try to set cookie

    cookie(key, '1');
    var valueSet = document.cookie.indexOf(key) !== -1; // Cleanup cookie

    cookie(key, '', -1);
    return valueSet;
  } catch (e) {
    return false;
  }
}

/**
 * Get a cookie value
 * @param  {string} name - key of cookie
 * @return {string} value of cookie
 */

var getCookie = cookie;
/**
 * Set a cookie value
 * @param {string} name  - key of cookie
 * @param {string} value - value of cookie
 * @param {string} days  - days to keep cookie
 */

var setCookie = cookie;
/**
 * Remove a cookie value.
 * @param {string} name  - key of cookie
 */

function removeCookie(name) {
  return cookie(name, '', -1);
}

exports.hasCookieSupport = hasCookieSupport;
exports.setCookie = setCookie;
exports.getCookie = getCookie;
exports.removeCookie = removeCookie;

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var analyticsUtils = require('analytics-utils');

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

var arrayWithoutHoles = _arrayWithoutHoles;

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

var iterableToArray = _iterableToArray;

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var nonIterableSpread = _nonIterableSpread;

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

var toConsumableArray = _toConsumableArray;

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _typeof_1 = createCommonjsModule(function (module) {
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
});

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  module.exports
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

var regenerator = runtime_1;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

var asyncToGenerator = _asyncToGenerator;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty;

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var objectSpread2 = _objectSpread2;

var FUNC = 'function';
var UNDEF = 'undefined';
var REDUCER = 'reducer';
var base = '@@redux/';
var ACTION_INIT = base + 'INIT';
var ACTION_TEST = base + Math.random().toString(36);

var $$observable =
/* #__PURE__ */
function () {
  return (typeof Symbol === "undefined" ? "undefined" : _typeof_1(Symbol)) === FUNC && Symbol.observable || '@@observable';
}();
/*
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */


var msg = ' != ' + FUNC;
function createStore(reducer, preloadedState, enhancer) {
  if (_typeof_1(preloadedState) === FUNC && _typeof_1(enhancer) === UNDEF) {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (_typeof_1(enhancer) !== UNDEF) {
    if (_typeof_1(enhancer) !== FUNC) {
      throw new Error('enhancer' + msg);
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (_typeof_1(reducer) !== FUNC) {
    throw new Error(REDUCER + msg);
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /*
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    return currentState;
  }
  /*
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (_typeof_1(listener) !== FUNC) {
      throw new Error('Listener' + msg);
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    /* // add default info to actions... 
    console.log('dispatch before', _action)
    const action = {
      ..._action,
      ...{
        action: {
          ..._action.action,
          ...{ customInfo: 'yoooo'} 
        }
      }
    }
    console.log('dispatch after', action)
    /** */
    if (!analyticsUtils.isObject(action)) {
      throw new Error('Act != obj');
    }

    if (_typeof_1(action.type) === UNDEF) {
      throw new Error('ActType ' + UNDEF);
    }

    if (isDispatching) {
      throw new Error('Dispatch in ' + REDUCER);
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (_typeof_1(nextReducer) !== FUNC) {
      throw new Error('next ' + REDUCER + msg);
    }

    currentReducer = nextReducer;
    dispatch({
      type: ACTION_INIT
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var outerSubscribe = subscribe;
    return defineProperty({
      /*
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (_typeof_1(observer) !== 'object') {
          throw new TypeError('Observer != obj');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, $$observable, function () {
      return this;
    });
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ACTION_INIT
  });
  return defineProperty({
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, $$observable, observable);
}

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionName = actionType && actionType.toString() || '?';
  return 'action ' + actionName + REDUCER + ' ' + key + ' returns ' + UNDEF;
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ACTION_INIT
    });

    if (_typeof_1(initialState) === UNDEF || _typeof_1(reducer(undefined, {
      type: ACTION_TEST
    })) === UNDEF) {
      throw new Error(REDUCER + ' ' + key + ' ' + UNDEF);
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (_typeof_1(reducers[key]) === FUNC) {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers);

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = arguments.length > 1 ? arguments[1] : undefined;

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (_typeof_1(nextStateForKey) === UNDEF) {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    return hasChanged ? nextState : state;
  };
}

function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, preloadedState, enhancer) {
      var store = createStore(reducer, preloadedState, enhancer);
      var _dispatch = store.dispatch;
      var chain = [];
      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, toConsumableArray(chain))(store.dispatch);
      return objectSpread2(objectSpread2({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}

var coreEvents = [
/**
 * `bootstrap` - Fires when analytics library starts up.
 * This is the first event fired. '.on/once' listeners are not allowed on bootstrap
 * Plugins can attach logic to this event
 */
'bootstrap',
/**
 * `params` - Fires when analytics parses URL parameters
 */
'params',
/**
 * `campaign` - Fires if params contain "utm" parameters
 */
'campaign',
/**
 * `initializeStart` - Fires before 'initialize', allows for plugins to cancel loading of other plugins
 */
'initializeStart',
/**
 * `initialize` - Fires when analytics loads plugins
 */
'initialize',
/**
 * `initializeEnd` - Fires after initialize, allows for plugins to run logic after initialization methods run
 */
'initializeEnd',
/**
 * `ready` - Fires when all analytic providers are fully loaded. This waits for 'initialize' and 'loaded' to return true
 */
'ready',
/**
 * `resetStart` - Fires if analytic.reset() is called.
 * Use this event to cancel reset based on a specific condition
 */
'resetStart',
/**
 * `reset` - Fires if analytic.reset() is called.
 * Use this event to run custom cleanup logic (if needed)
 */
'reset',
/**
 * `resetEnd` - Fires after analytic.reset() is called.
 * Use this event to run a callback after user data is reset
 */
'resetEnd',
/******************
 * Page Events
 ******************/

/**
 * `pageStart` - Fires before 'page' events fire.
 *  This allows for dynamic page view cancellation based on current state of user or options passed in.
 */
'pageStart',
/**
 * `page` - Core analytics hook for page views.
 *  If your plugin or integration tracks page views, this is the event to fire on.
 */
'page',
/**
 * `pageEnd` - Fires after all registered 'page' methods fire.
 */
'pageEnd',
/**
 * `pageAborted` - Fires if 'page' call is cancelled by a plugin
 */
'pageAborted',
/****************
 * Track Events
 ***************/

/**
 * `trackStart` - Called before the 'track' events fires.
 *  This allows for dynamic page view cancellation based on current state of user or options passed in.
 */
'trackStart',
/**
 * `track` - Core analytics hook for event tracking.
 *  If your plugin or integration tracks custom events, this is the event to fire on.
 */
'track',
/**
 * `trackEnd` - Fires after all registered 'track' events fire from plugins.
 */
'trackEnd',
/**
 * `trackAborted` - Fires if 'track' call is cancelled by a plugin
 */
'trackAborted',
/******************
 * Identify Events
 ******************/

/**
 * `identifyStart` - Called before the 'identify' events fires.
 * This allows for dynamic page view cancellation based on current state of user or options passed in.
 */
'identifyStart',
/**
 * `identify` - Core analytics hook for user identification.
 *  If your plugin or integration identifies users or user traits, this is the event to fire on.
 */
'identify',
/**
 * `identifyEnd` - Fires after all registered 'identify' events fire from plugins.
 */
'identifyEnd',
/**
 * `identifyAborted` - Fires if 'track' call is cancelled by a plugin
 */
'identifyAborted',
/**
 * `userIdChanged` - Fires when a user id is updated
 */
'userIdChanged',
/******************
 * Plugin Events
 ******************/

/**
 * `registerPlugins` - Fires when analytics is registering plugins
 */
'registerPlugins',
/**
 * `enablePlugin` - Fires when 'analytics.plugins.enable()' is called
 */
'enablePlugin',
/**
 * `disablePlugin` - Fires when 'analytics.plugins.disable()' is called
 */
'disablePlugin',
/*
 * `loadPlugin` - Fires when 'analytics.loadPlugin()' is called
 */
// 'loadPlugin',

/******************
 * Browser activity events
 ******************/

/**
 * `online` - Fires when browser network goes online.
 * This fires only when coming back online from an offline state.
 */
'online',
/**
 * `offline` - Fires when browser network goes offline.
 */
'offline',
/******************
 * Storage events
 ******************/

/**
 * `setItemStart` - Fires when analytics.storage.setItem is initialized.
 * This event gives plugins the ability to intercept keys & values and alter them before they are persisted.
 */
'setItemStart',
/**
 * `setItem` - Fires when analytics.storage.setItem is called.
 * This event gives plugins the ability to intercept keys & values and alter them before they are persisted.
 */
'setItem',
/**
 * `setItemEnd` - Fires when setItem storage is complete.
 */
'setItemEnd',
/**
 * `setItemAborted` - Fires when setItem storage is cancelled by a plugin.
 */
'setItemAborted',
/**
 * `removeItemStart` - Fires when analytics.storage.removeItem is initialized.
 * This event gives plugins the ability to intercept removeItem calls and abort / alter them.
 */
'removeItemStart',
/**
 * `removeItem` - Fires when analytics.storage.removeItem is called.
 * This event gives plugins the ability to intercept removeItem calls and abort / alter them.
 */
'removeItem',
/**
 * `removeItemEnd` - Fires when removeItem storage is complete.
 */
'removeItemEnd',
/**
 * `removeItemAborted` - Fires when removeItem storage is cancelled by a plugin.
 */
'removeItemAborted'];
/* Keys on a plugin that are not considered events */

var nonEvents = ['name', 'EVENTS', 'config', 'loaded'];
var pluginEvents = {
  registerPluginType: function registerPluginType(name) {
    return "registerPlugin:".concat(name);
  },
  pluginReadyType: function pluginReadyType(name) {
    return "ready:".concat(name);
  }
};
var EVENTS = coreEvents.reduce(function (acc, curr) {
  acc[curr] = curr;
  return acc;
}, pluginEvents);
function isReservedAction(type) {
  return coreEvents.includes(type);
}

var LIBRARY_NAME = 'analytics';
var ID = 'userId';
var ANONID = 'anonymousId';
var ERROR_URL = 'https://lytics.dev/errors/';
var PREFIX = '__';

/**
 * Anonymous visitor Id localstorage key
 * @typedef {String} ANON_ID
 */

var ANON_ID = PREFIX + 'anon_id'; // __anon_id

/**
 * Visitor Id localstorage key
 * @typedef {String} USER_ID
 */

var USER_ID = PREFIX + 'user_id'; // __user_id

/**
 * Visitor traits localstorage key
 * @typedef {String} USER_TRAITS
 */

var USER_TRAITS = PREFIX + 'user_traits'; // __user_traits

var constants = /*#__PURE__*/Object.freeze({
  ANON_ID: ANON_ID,
  USER_ID: USER_ID,
  USER_TRAITS: USER_TRAITS
});

var utmRegex = /^utm_/;
var propRegex = /^an_prop_/;
var traitRegex = /^an_trait_/; // Middleware runs during EVENTS.initialize

function initializeMiddleware(instance) {
  var _instance$storage = instance.storage,
      setItem = _instance$storage.setItem,
      getItem = _instance$storage.getItem;
  return function (store) {
    return function (next) {
      return function (action) {
        /* Handle bootstrap event */
        if (action.type === EVENTS.bootstrap) {
          var params = action.params,
              user = action.user,
              persistedUser = action.persistedUser;
          /* 1. Set anonymous ID */

          if (persistedUser.anonymousId !== user.anonymousId) {
            setItem(ANON_ID, user.anonymousId);
          }
          /* 2. Set userId */


          if (persistedUser.userId !== user.userId) {
            setItem(USER_ID, user.userId);
          }
          /* 3. Parse url params */


          var paramsArray = Object.keys(action.params);

          if (paramsArray.length) {
            var an_uid = params.an_uid,
                an_event = params.an_event;
            var groupedParams = paramsArray.reduce(function (acc, key) {
              // match utm params & dclid (display) & gclid (cpc)
              if (key.match(utmRegex) || key.match(/^(d|g)clid/)) {
                var cleanName = key.replace(utmRegex, '');
                var keyName = cleanName === 'campaign' ? 'name' : cleanName;
                acc.campaign[keyName] = params[key];
              }

              if (key.match(propRegex)) {
                acc.props[key.replace(propRegex, '')] = params[key];
              }

              if (key.match(traitRegex)) {
                acc.traits[key.replace(traitRegex, '')] = params[key];
              }

              return acc;
            }, {
              campaign: {},
              props: {},
              traits: {}
            });
            store.dispatch(objectSpread2(objectSpread2({
              type: EVENTS.params,
              raw: params
            }, groupedParams), an_uid ? {
              userId: an_uid
            } : {}));
            /* If userId set, call identify */

            if (an_uid) {
              // timeout to debounce and make sure integration is registered. Todo refactor
              setTimeout(function () {
                return instance.identify(an_uid, groupedParams.traits);
              }, 0);
            }
            /* If tracking event set, call track */


            if (an_event) {
              // timeout to debounce and make sure integration is registered. Todo refactor
              setTimeout(function () {
                return instance.track(an_event, groupedParams.props);
              }, 0);
            } // if url has utm params


            if (Object.keys(groupedParams.campaign).length) {
              store.dispatch({
                type: EVENTS.campaign,
                campaign: groupedParams.campaign
              });
            }
          }
        }

        return next(action);
      };
    };
  };
}

/* user reducer */

function userReducer(storage) {
  return function user() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (action.type === EVENTS.setItemEnd) {
      // Set anonymousId if changed by storage.setItem
      if (action.key === ANON_ID) {
        return objectSpread2(objectSpread2({}, state), {
          anonymousId: action.value
        });
      } // Set userId if changed by storage.setItem


      if (action.key === USER_ID) {
        return objectSpread2(objectSpread2({}, state), {
          userId: action.value
        });
      }
    }

    switch (action.type) {
      case EVENTS.identify:
        return Object.assign({}, state, {
          userId: action.userId,
          traits: objectSpread2(objectSpread2({}, state.traits), action.traits)
        });

      case EVENTS.reset:
        // Side effect to fix race condition in Node. TODO refactor
        // This is from default storage.removeItem: (key) => globalContext[key] = undefined
        [USER_ID, ANON_ID, USER_TRAITS].forEach(function (key) {
          // sync storage, not instance.storage
          storage.removeItem(key);
        });
        return Object.assign({}, state, {
          userId: null,
          // TODO reset anon id automatically?
          anonymousId: null,
          traits: {}
        });

      default:
        return state;
    }
  };
}
function getPersistedUserData(storage) {
  return {
    userId: storage.getItem(USER_ID),
    anonymousId: storage.getItem(ANON_ID),
    traits: storage.getItem(USER_TRAITS) || {}
  };
}
var tempKey = function tempKey(key) {
  return PREFIX + 'TEMP' + PREFIX + key;
};
function getUserPropFunc(storage) {
  return function getUserProp(key, instance, payload) {
    /* 1. Try current state */
    var currentId = instance.getState('user')[key];

    if (currentId) {
      /*
      console.log(`from state ${key}`, currentId)
      /** */
      return currentId;
    }
    /* 2. Try event payload */


    if (payload && analyticsUtils.isObject(payload) && payload[key]) {
      /*
      console.log(`from payload ${key}`, payload[key])
      /** */
      return payload[key];
    }
    /* 3. Try persisted data */


    var persistedInfo = getPersistedUserData(storage)[key];

    if (persistedInfo) {
      /*
      console.log(`from persistedInfo ${key}`, persistedInfo)
      /** */
      return persistedInfo;
    }
    /* 4. Else, try to get in memory placeholder. TODO watch this for future issues */


    if (analyticsUtils.globalContext[tempKey(key)]) {
      /*
      console.log(`from global ${key}`, globalContext[tempKey(key)])
      /** */
      return analyticsUtils.globalContext[tempKey(key)];
    } // return null instead of undefined for consistency


    return null;
  };
}

function identifyMiddleware(instance) {
  var _instance$storage = instance.storage,
      setItem = _instance$storage.setItem,
      removeItem = _instance$storage.removeItem,
      getItem = _instance$storage.getItem;
  return function (store) {
    return function (next) {
      return function (action) {
        var userId = action.userId,
            traits = action.traits,
            options = action.options;
        /* Reset user id and traits */

        if (action.type === EVENTS.reset) {
          // Remove stored data
          [USER_ID, USER_TRAITS, ANON_ID].forEach(function (key) {
            // Fires async removeItem dispatch
            removeItem(key);
          });
          [ID, ANONID, 'traits'].forEach(function (key) {
            analyticsUtils.globalContext[tempKey(key)] = undefined;
          });
        }

        if (action.type === EVENTS.identify) {
          /* If no anon id. Set it! */
          if (!getItem(ANON_ID)) {
            setItem(ANON_ID, analyticsUtils.uuid());
          }

          var currentId = getItem(USER_ID);
          var currentTraits = getItem(USER_TRAITS) || {};

          if (currentId && currentId !== userId) {
            store.dispatch({
              type: EVENTS.userIdChanged,
              old: {
                userId: currentId,
                traits: currentTraits
              },
              "new": {
                userId: userId,
                traits: traits
              },
              options: options
            });
          }
          /* Save user id */


          if (userId) {
            setItem(USER_ID, userId);
          }
          /* Save user traits */


          if (traits) {
            setItem(USER_TRAITS, objectSpread2(objectSpread2({}, currentTraits), traits));
          }
        }

        return next(action);
      };
    };
  };
}

var stack = {};
/*
window.callBackStack = stack
/** */

function runCallback(id, payload) {
  if (stack[id] && analyticsUtils.isFunction(stack[id])) {
    // console.log(`run ${id}`)
    stack[id](payload);
    delete stack[id];
  }
}

function waitForReady(data, predicate, timeout) {
  return new Promise(function (resolve, reject) {
    if (predicate()) {
      return resolve(data);
    } // Timeout. Add to queue


    if (timeout < 1) {
      return reject(objectSpread2(objectSpread2({}, data), {}, {
        queue: true
      })); // eslint-disable-line
    } // Else recursive retry


    return pause(10).then(function (_) {
      return waitForReady(data, predicate, timeout - 10).then(resolve, reject);
    });
  });
}

function pause(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
}

function processQueue(store, getPlugins, instance) {
  var pluginMethods = getPlugins();

  var _store$getState = store.getState(),
      plugins = _store$getState.plugins,
      context = _store$getState.context,
      queue = _store$getState.queue,
      user = _store$getState.user;

  var isOnline = !context.offline;
  /* If network connection found and there is items in queue, process them all */

  if (isOnline && queue && queue.actions && queue.actions.length) {
    var pipeline = queue.actions.reduce(function (acc, item, index) {
      var isLoaded = plugins[item.plugin].loaded;

      if (isLoaded) {
        acc.process.push(item);
        acc.processIndex.push(index);
      } else {
        acc.requeue.push(item);
        acc.requeueIndex.push(index);
      }

      return acc;
    }, {
      processIndex: [],
      process: [],
      requeue: [],
      requeueIndex: []
    });

    if (pipeline.processIndex && pipeline.processIndex.length) {
      pipeline.processIndex.forEach(function (i) {
        var processAction = queue.actions[i]; // console.log('RePROCESS THIS>', processAction)
        // Call methods directly right now

        var currentPlugin = processAction.plugin;
        var currentMethod = processAction.payload.type;
        var method = pluginMethods[currentPlugin][currentMethod];

        if (method && analyticsUtils.isFunction(method)) {
          /* enrich queued payload with userId / anon id if missing */

          /* TODO hoist enrich into where action queued? */
          // console.log('before', processAction.payload)
          var enrichedPayload = enrich(processAction.payload, user); // console.log('user.userId', user.userId)
          // console.log('user.anonymousId', user.anonymousId)
          // console.log('after enrich', enrichedPayload)

          method({
            payload: enrichedPayload,
            config: plugins[currentPlugin].config,
            instance: instance
          });
          /* Then redispatch for .on listeners / other middleware */

          var pluginEvent = "".concat(currentMethod, ":").concat(currentPlugin);
          store.dispatch(objectSpread2(objectSpread2({}, enrichedPayload), {}, {
            type: pluginEvent,

            /* Internal data for analytics engine */
            _: {
              called: pluginEvent,
              from: 'queueDrain'
            }
          }));
        }
      });
      /* Removed processed actions */

      var reQueueActions = queue.actions.filter(function (value, index) {
        // !~ === return pipeline.processIndex.indexOf(index) === -1
        return !~pipeline.processIndex.indexOf(index);
      });
      /* Set queue actions. TODO refactor to non mutatable or move out of redux */

      queue.actions = reQueueActions;
    }
  }
}
/* Heartbeat retries queued events */

function heartBeat(store, getPlugins, instance) {
  // 3e3 === 3000 ms
  return setInterval(function () {
    return processQueue(store, getPlugins, instance);
  }, 3e3);
} // Assign userId && anonymousId values if present in payload but null

function enrich() {
  var payload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var user = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return [ID, ANONID].reduce(function (acc, key) {
    if (payload.hasOwnProperty(key) && user[key] && user[key] !== payload[key]) {
      // console.log(`${key} stale update with ${user[key]}`)
      acc[key] = user[key];
    }

    return acc;
  }, payload);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var arrayWithHoles = _arrayWithHoles;

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

var iterableToArrayLimit = _iterableToArrayLimit;

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var nonIterableRest = _nonIterableRest;

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

var slicedToArray = _slicedToArray;

function fitlerDisabledPlugins(allPlugins) {
  var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return Object.keys(allPlugins).filter(function (name) {
    var fromCallOptions = options.plugins || {}; // If enabled/disabled by options. Override settings

    if (analyticsUtils.isBoolean(fromCallOptions[name])) {
      return fromCallOptions[name];
    } // If all: false disable everything unless true explicitly set


    if (fromCallOptions.all === false) {
      return false;
    } // else use state.plugin settings


    if (settings[name] && settings[name].enabled === false) {
      return false;
    }

    return true;
  }).map(function (name) {
    return allPlugins[name];
  });
}

var endsWithStartRegex = /Start$/;
var bootstrapRegex = /^bootstrap/;
var readyRegex = /^ready/;
function runPlugins (_x, _x2, _x3, _x4, _x5) {
  return _ref.apply(this, arguments);
}
/**
 * Async reduce over matched plugin methods
 * Fires plugin functions
 */

function _ref() {
  _ref = asyncToGenerator(
  /*#__PURE__*/
  regenerator.mark(function _callee(action, getPlugins, instance, store, eventsInfo) {
    var pluginObject, originalType, updatedType, state, activePlugins, allActivePluginKeys, allMatches, actionBefore, actionDuring, afterName, actionAfter;
    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            pluginObject = analyticsUtils.isFunction(getPlugins) ? getPlugins() : getPlugins;
            originalType = action.type;
            updatedType = originalType.replace(endsWithStartRegex, '');
            /* If action already dispatched exit early. This makes it so plugin methods are not fired twice. */

            if (!(action._ && action._.called)) {
              _context.next = 5;
              break;
            }

            return _context.abrupt("return", action);

          case 5:
            state = instance.getState();
            /* Remove plugins that are disabled by options or by settings */

            activePlugins = fitlerDisabledPlugins(pluginObject, state.plugins, action.options);
            /* If analytics.plugin.enable calls do special behavior */

            if (originalType === EVENTS.initializeStart && action.fromEnable) {
              // Return list of all enabled plugins that have NOT been initialized yet
              activePlugins = Object.keys(state.plugins).filter(function (name) {
                var info = state.plugins[name];
                return action.plugins.includes(name) && !info.initialized;
              }).map(function (name) {
                return pluginObject[name];
              });
            } // console.log(`engine activePlugins ${action.type}`, activePlugins)


            allActivePluginKeys = activePlugins.map(function (p) {
              return p.name;
            }); // console.log('allActivePluginKeys', allActivePluginKeys)

            allMatches = getAllMatchingCalls(originalType, activePlugins, pluginObject); // console.log('allMatches', allMatches)

            /* @TODO cache matches and purge on enable/disable/add plugin */

            /**
             * Process all 'actionBefore' hooks
             * Example:
             *  This is processes 'pageStart' methods from plugins and update the event to send through the chain
             */

            _context.next = 12;
            return processEvent({
              action: action,
              data: {
                exact: allMatches.before,
                namespaced: allMatches.beforeNS
              },
              state: state,
              allPlugins: pluginObject,
              allMatches: allMatches,
              instance: instance,
              store: store,
              EVENTS: eventsInfo
            });

          case 12:
            actionBefore = _context.sent;

            if (!shouldAbortAll(actionBefore, allActivePluginKeys.length)) {
              _context.next = 15;
              break;
            }

            return _context.abrupt("return", actionBefore);

          case 15:
            if (!(originalType === updatedType)) {
              _context.next = 19;
              break;
            }

            /* If type the same don't double process */
            actionDuring = actionBefore;
            _context.next = 22;
            break;

          case 19:
            _context.next = 21;
            return processEvent({
              action: objectSpread2(objectSpread2({}, actionBefore), {}, {
                type: updatedType
              }),
              data: {
                exact: allMatches.during,
                namespaced: allMatches.duringNS
              },
              state: state,
              allPlugins: pluginObject,
              allMatches: allMatches,
              instance: instance,
              store: store,
              EVENTS: eventsInfo
            });

          case 21:
            actionDuring = _context.sent;

          case 22:
            if (!originalType.match(endsWithStartRegex)) {
              _context.next = 28;
              break;
            }

            afterName = "".concat(updatedType, "End");
            _context.next = 26;
            return processEvent({
              action: objectSpread2(objectSpread2({}, actionDuring), {}, {
                type: afterName
              }),
              data: {
                exact: allMatches.after,
                namespaced: allMatches.afterNS
              },
              state: state,
              allPlugins: pluginObject,
              allMatches: allMatches,
              instance: instance,
              store: store,
              EVENTS: eventsInfo
            });

          case 26:
            actionAfter = _context.sent;

            // console.log('____ actionAfter', actionAfter)

            /* Fire callback if supplied */
            if (actionAfter.meta && actionAfter.meta.hasCallback) {
              /*
              console.log('End of engine action has callback')
              console.log(actionAfter.meta)
              console.log('stack', stack)
              /** */
              // @TODO figure out exact args calls and .on will get
              runCallback(actionAfter.meta.rid, {
                payload: actionAfter
              });
            }

          case 28:
            return _context.abrupt("return", actionBefore);

          case 29:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _ref.apply(this, arguments);
}

function processEvent(_x6) {
  return _processEvent.apply(this, arguments);
}

function _processEvent() {
  _processEvent = asyncToGenerator(
  /*#__PURE__*/
  regenerator.mark(function _callee5(_ref2) {
    var data, action, instance, state, allPlugins, allMatches, store, EVENTS$$1, plugins, context, method, isStartEvent, abortable, makeArgs, queueData, payloads, resolvedAction, endAction;
    return regenerator.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            data = _ref2.data, action = _ref2.action, instance = _ref2.instance, state = _ref2.state, allPlugins = _ref2.allPlugins, allMatches = _ref2.allMatches, store = _ref2.store, EVENTS$$1 = _ref2.EVENTS;
            plugins = state.plugins, context = state.context;
            method = action.type;
            isStartEvent = method.match(endsWithStartRegex); // console.log(`data ${method}`, data)
            // console.log(`data allMatches ${method}`, allMatches)

            abortable = data.exact.map(function (x) {
              return x.pluginName;
            });
            /* If abort is called from xyzStart */

            if (isStartEvent) {
              abortable = allMatches.during.map(function (x) {
                return x.pluginName;
              });
            }
            /* make args for functions to concume */


            makeArgs = argumentFactory(instance, abortable); // console.log('makeArgs', makeArgs)

            /* Check if plugin loaded, if not mark action for queue */

            queueData = data.exact.reduce(function (acc, thing) {
              var pluginName = thing.pluginName,
                  methodName = thing.methodName;
              var addToQueue = false; // Queue actions if plugin not loaded except for initialize and reset

              if (!methodName.match(/^initialize/) && !methodName.match(/^reset/)) {
                addToQueue = !plugins[pluginName].loaded;
              }
              /* If offline and its a core method. Add to queue */


              if (context.offline && methodName.match(/^(page|track|identify)/)) {
                addToQueue = true;
              }

              acc["".concat(pluginName)] = addToQueue;
              return acc;
            }, {});
            /* generate plugin specific payloads */

            _context5.next = 10;
            return data.exact.reduce(
            /*#__PURE__*/
            function () {
              var _ref6 = asyncToGenerator(
              /*#__PURE__*/
              regenerator.mark(function _callee3(scoped, curr, i) {
                var pluginName, curScope, scopedPayload;
                return regenerator.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        pluginName = curr.pluginName;
                        _context3.next = 3;
                        return scoped;

                      case 3:
                        curScope = _context3.sent;

                        if (!(data.namespaced && data.namespaced[pluginName])) {
                          _context3.next = 11;
                          break;
                        }

                        _context3.next = 7;
                        return data.namespaced[pluginName].reduce(
                        /*#__PURE__*/
                        function () {
                          var _ref7 = asyncToGenerator(
                          /*#__PURE__*/
                          regenerator.mark(function _callee2(acc, p, count) {
                            var curScopeData, genAbort, val, returnValue;
                            return regenerator.wrap(function _callee2$(_context2) {
                              while (1) {
                                switch (_context2.prev = _context2.next) {
                                  case 0:
                                    genAbort = function _ref8(currentAct, pname, otherPlug) {
                                      return function (reason, plugins) {
                                        var callsite = otherPlug || pname; // console.log(`__abort msg: ${reason}`)
                                        // console.log(`__abort ${pname}`)
                                        // console.log(`__abort xxx: ${plugins}`)
                                        // console.log(`__abort otherPlug`, otherPlug)

                                        return objectSpread2(objectSpread2({}, currentAct), {}, {
                                          abort: {
                                            reason: reason,
                                            plugins: plugins || [pname],
                                            caller: method,
                                            from: callsite
                                          }
                                        });
                                      };
                                    };

                                    _context2.next = 3;
                                    return acc;

                                  case 3:
                                    curScopeData = _context2.sent;

                                    if (!(!p.method || !analyticsUtils.isFunction(p.method))) {
                                      _context2.next = 6;
                                      break;
                                    }

                                    return _context2.abrupt("return", curScopeData);

                                  case 6:
                                    /* Make sure plugins don’t call themselves */
                                    validateMethod(p.methodName, p.pluginName);
                                    _context2.next = 9;
                                    return p.method({
                                      payload: curScopeData,
                                      instance: instance,
                                      abort: genAbort(curScopeData, pluginName, p.pluginName),
                                      config: getConfig(p.pluginName, plugins, allPlugins),
                                      plugins: plugins
                                    });

                                  case 9:
                                    val = _context2.sent;
                                    returnValue = analyticsUtils.isObject(val) ? val : {};
                                    return _context2.abrupt("return", Promise.resolve(objectSpread2(objectSpread2({}, curScopeData), returnValue)));

                                  case 12:
                                  case "end":
                                    return _context2.stop();
                                }
                              }
                            }, _callee2);
                          }));

                          return function (_x10, _x11, _x12) {
                            return _ref7.apply(this, arguments);
                          };
                        }(), Promise.resolve(action));

                      case 7:
                        scopedPayload = _context3.sent;

                        /* Set scoped payload */
                        curScope[pluginName] = scopedPayload;
                        _context3.next = 12;
                        break;

                      case 11:
                        /* Set payload as default action */
                        curScope[pluginName] = action;

                      case 12:
                        return _context3.abrupt("return", Promise.resolve(curScope));

                      case 13:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));

              return function (_x7, _x8, _x9) {
                return _ref6.apply(this, arguments);
              };
            }(), Promise.resolve({}));

          case 10:
            payloads = _context5.sent;
            _context5.next = 13;
            return data.exact.reduce(
            /*#__PURE__*/
            function () {
              var _ref9 = asyncToGenerator(
              /*#__PURE__*/
              regenerator.mark(function _callee4(promise, curr, i) {
                var lastLoop, pluginName, currentPlugin, currentActionValue, payloadValue, funcArgs, val, returnValue, merged, scopedPayload, nameSpaceEvent, actionDepth, updatedPayload;
                return regenerator.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        lastLoop = data.exact.length === i + 1;
                        pluginName = curr.pluginName;
                        currentPlugin = allPlugins[pluginName];
                        _context4.next = 5;
                        return promise;

                      case 5:
                        currentActionValue = _context4.sent;
                        payloadValue = payloads[pluginName] ? payloads[pluginName] : {};
                        /* If eventStart, allow for value merging */

                        if (isStartEvent) {
                          payloadValue = currentActionValue;
                        }

                        if (!shouldAbort(payloadValue, pluginName)) {
                          _context4.next = 11;
                          break;
                        }

                        // console.log(`> Abort from payload specific "${pluginName}" abort value`, payloadValue)
                        abortDispatch({
                          data: payloadValue,
                          method: method,
                          instance: instance,
                          pluginName: pluginName,
                          store: store
                        });
                        return _context4.abrupt("return", Promise.resolve(currentActionValue));

                      case 11:
                        if (!shouldAbort(currentActionValue, pluginName)) {
                          _context4.next = 14;
                          break;
                        }

                        // console.log(`> Abort from ${method} abort value`, currentActionValue)
                        if (lastLoop) {
                          abortDispatch({
                            data: currentActionValue,
                            method: method,
                            instance: instance,
                            // pluginName,
                            store: store
                          });
                        }

                        return _context4.abrupt("return", Promise.resolve(currentActionValue));

                      case 14:
                        if (!(queueData.hasOwnProperty(pluginName) && queueData[pluginName] === true)) {
                          _context4.next = 17;
                          break;
                        }

                        // console.log('Queue this instead', pluginName)
                        store.dispatch({
                          type: "queue",
                          plugin: pluginName,
                          payload: payloadValue,

                          /* Internal data for analytics engine */
                          _: {
                            called: "queue",
                            from: 'queueMechanism' // for debugging

                          }
                        });
                        return _context4.abrupt("return", Promise.resolve(currentActionValue));

                      case 17:
                        /*
                        const checkForLoaded = () => {
                          const p = instance.getState('plugins')
                          return p[currentPlugin.name].loaded
                        }
                        // const p = instance.getState('plugins')
                        console.log(`loaded "${currentPlugin.name}" > ${method}:`, p[currentPlugin.name].loaded)
                        // await waitForReady(currentPlugin, checkForLoaded, 10000).then((d) => {
                        //   console.log(`Loaded ${method}`, currentPlugin.name)
                        // }).catch((e) => {
                        //   console.log(`Error ${method} ${currentPlugin.name}`, e)
                        //   // TODO dispatch failure
                        // })
                        */
                        // @TODO figure out if we want queuing semantics
                        funcArgs = makeArgs(payloads[pluginName], allPlugins[pluginName]); // console.log(`funcArgs ${method} ${pluginName}`, funcArgs)

                        /* Run the plugin function */

                        _context4.next = 20;
                        return currentPlugin[method]({
                          // currentPlugin: pluginName,
                          abort: funcArgs.abort,
                          // Send in original action value or scope payload
                          payload: payloadValue,
                          instance: instance,
                          config: getConfig(pluginName, plugins, allPlugins),
                          plugins: plugins
                        });

                      case 20:
                        val = _context4.sent;
                        returnValue = analyticsUtils.isObject(val) ? val : {};
                        merged = objectSpread2(objectSpread2({}, currentActionValue), returnValue);
                        scopedPayload = payloads[pluginName]; // || currentActionValue

                        if (shouldAbort(scopedPayload, pluginName)) {
                          // console.log(`>> HANDLE abort ${method} ${pluginName}`)
                          abortDispatch({
                            data: scopedPayload,
                            method: method,
                            instance: instance,
                            pluginName: pluginName,
                            store: store
                          });
                        } else {
                          nameSpaceEvent = "".concat(method, ":").concat(pluginName);
                          actionDepth = (nameSpaceEvent.match(/:/g) || []).length;

                          if (actionDepth < 2 && !method.match(bootstrapRegex) && !method.match(readyRegex)) {
                            updatedPayload = isStartEvent ? merged : payloadValue; // Dispatched for `.on('xyz') listeners.

                            instance.dispatch(objectSpread2(objectSpread2({}, updatedPayload), {}, {
                              type: nameSpaceEvent,
                              _: {
                                called: nameSpaceEvent,
                                from: 'submethod'
                              }
                            }));
                          }
                        } // console.log('merged', merged)


                        return _context4.abrupt("return", Promise.resolve(merged));

                      case 26:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));

              return function (_x13, _x14, _x15) {
                return _ref9.apply(this, arguments);
              };
            }(), Promise.resolve(action));

          case 13:
            resolvedAction = _context5.sent;

            if (!(!method.match(endsWithStartRegex) && !method.match(/^registerPlugin/) && // !method.match(/^disablePlugin/) &&
            // !method.match(/^enablePlugin/) &&
            !method.match(readyRegex) && !method.match(bootstrapRegex) && !method.match(/^params/) && !method.match(/^userIdChanged/))) {
              _context5.next = 21;
              break;
            }

            if (EVENTS$$1.plugins.includes(method)) ; // console.log(`Dont dispatch for ${method}`, resolvedAction)
            // return resolvedAction

            /*
              Verify this original action setup.
              It's intended to keep actions from double dispatching themselves
            */


            if (!(resolvedAction._ && resolvedAction._.originalAction === method)) {
              _context5.next = 18;
              break;
            }

            return _context5.abrupt("return", resolvedAction);

          case 18:
            endAction = objectSpread2(objectSpread2({}, resolvedAction), {
              _: {
                originalAction: resolvedAction.type,
                called: resolvedAction.type,
                from: 'engineEnd'
              }
            });
            /* If all plugins are aborted, dispatch xAborted */

            if (shouldAbortAll(resolvedAction, data.exact.length) && !method.match(/End$/)) {
              endAction = objectSpread2(objectSpread2({}, endAction), {
                type: resolvedAction.type + 'Aborted'
              });
            }

            store.dispatch(endAction);

          case 21:
            return _context5.abrupt("return", resolvedAction);

          case 22:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _processEvent.apply(this, arguments);
}

function abortDispatch(_ref3) {
  var data = _ref3.data,
      method = _ref3.method,
      instance = _ref3.instance,
      pluginName = _ref3.pluginName,
      store = _ref3.store;
  var postFix = pluginName ? ':' + pluginName : '';
  var abortEvent = method + 'Aborted' + postFix;
  store.dispatch(objectSpread2(objectSpread2({}, data), {}, {
    type: abortEvent,
    _: {
      called: abortEvent,
      from: 'abort'
    }
  }));
}

function getConfig(name, pluginState, allPlugins) {
  var pluginData = pluginState[name] || allPlugins[name];

  if (pluginData && pluginData.config) {
    return pluginData.config;
  }

  return {};
}

function getPluginFunctions(methodName, plugins) {
  return plugins.reduce(function (arr, plugin) {
    return !plugin[methodName] ? arr : arr.concat({
      methodName: methodName,
      pluginName: plugin.name,
      method: plugin[methodName]
    });
  }, []);
}

function formatMethod(type) {
  return type.replace(endsWithStartRegex, '');
}
/**
 * Return array of event names
 * @param  {String} eventType - original event type
 * @param  {String} namespace - optional namespace postfix
 * @return {array} - type, method, end
 */


function getEventNames(eventType, namespace) {
  var method = formatMethod(eventType);
  var postFix = namespace ? ":".concat(namespace) : ''; // `typeStart:pluginName`

  var type = "".concat(eventType).concat(postFix); // `type:pluginName`

  var methodName = "".concat(method).concat(postFix); // `typeEnd:pluginName`

  var end = "".concat(method, "End").concat(postFix);
  return [type, methodName, end];
}
/* Collect all calls for a given event in the system */


function getAllMatchingCalls(eventType, activePlugins, allPlugins) {
  var eventNames = getEventNames(eventType); // console.log('eventNames', eventNames)
  // 'eventStart', 'event', & `eventEnd`

  var core = eventNames.map(function (word) {
    return getPluginFunctions(word, activePlugins);
  }); // Gather nameSpaced Events

  return activePlugins.reduce(function (acc, plugin) {
    var name = plugin.name;
    var nameSpacedEvents = getEventNames(eventType, name); // console.log('eventNames namespaced', nameSpacedEvents)

    var _nameSpacedEvents$map = nameSpacedEvents.map(function (word) {
      return getPluginFunctions(word, activePlugins);
    }),
        _nameSpacedEvents$map2 = slicedToArray(_nameSpacedEvents$map, 3),
        beforeFuncs = _nameSpacedEvents$map2[0],
        duringFuncs = _nameSpacedEvents$map2[1],
        afterFuncs = _nameSpacedEvents$map2[2];

    if (beforeFuncs.length) {
      acc.beforeNS[name] = beforeFuncs;
    }

    if (duringFuncs.length) {
      acc.duringNS[name] = duringFuncs;
    }

    if (afterFuncs.length) {
      acc.afterNS[name] = afterFuncs;
    }

    return acc;
  }, {
    before: core[0],
    beforeNS: {},
    during: core[1],
    duringNS: {},
    after: core[2],
    afterNS: {}
  });
}

function shouldAbort(_ref4, pluginName) {
  var abort = _ref4.abort;
  if (!abort) return false;
  if (abort === true) return true;
  return includes(abort, pluginName) || abort && includes(abort.plugins, pluginName);
}

function shouldAbortAll(_ref5, pluginsCount) {
  var abort = _ref5.abort;
  if (!abort) return false;
  if (abort === true || analyticsUtils.isString(abort)) return true;
  var plugins = abort.plugins;
  return isArray(abort) && abort.length === pluginsCount || isArray(plugins) && plugins.length === pluginsCount;
}

function isArray(arr) {
  return Array.isArray(arr);
}

function includes(arr, name) {
  if (!arr || !isArray(arr)) return false;
  return arr.includes(name);
}
/**
 * Generate arguments to pass to plugin methods
 * @param  {Object} instance - analytics instance
 * @param  {array} abortablePlugins - plugins that can be cancelled by caller
 * @return {*} function to inject plugin params
 */


function argumentFactory(instance, abortablePlugins) {
  // console.log('abortablePlugins', abortablePlugins)
  return function (action, plugin, otherPlugin) {
    var config = plugin.config,
        name = plugin.name;
    var method = "".concat(name, ".").concat(action.type);

    if (otherPlugin) {
      method = otherPlugin.event;
    }

    var abortF = action.type.match(endsWithStartRegex) ? abortFunction(name, method, abortablePlugins, otherPlugin, action) : notAbortableError(action, method);
    return {
      /* self: plugin, for future maybe */
      // clone objects to avoid reassign
      payload: formatPayload(action),
      instance: instance,
      config: config || {},
      abort: abortF
    };
  };
}

function abortFunction(pluginName, method, abortablePlugins, otherPlugin, action) {
  return function (reason, plugins) {
    var caller = otherPlugin ? otherPlugin.name : pluginName;
    var pluginsToAbort = plugins && isArray(plugins) ? plugins : abortablePlugins;

    if (otherPlugin) {
      pluginsToAbort = plugins && isArray(plugins) ? plugins : [pluginName];

      if (!pluginsToAbort.includes(pluginName) || pluginsToAbort.length !== 1) {
        throw new Error("Method ".concat(method, " can only abort ").concat(pluginName, " plugin. ").concat(JSON.stringify(pluginsToAbort), " input valid"));
      }
    }

    return objectSpread2(objectSpread2({}, action), {}, {
      // 🔥 todo verify this merge is ok
      abort: {
        reason: reason,
        plugins: pluginsToAbort,
        caller: method,
        _: caller
      }
    });
  };
}

function notAbortableError(action, method) {
  return function () {
    throw new Error(action.type + ' action not cancellable. Remove abort in ' + method);
  };
}
/**
 * Verify plugin is not calling itself with whatever:myPluginName self refs
 */


function validateMethod(actionName, pluginName) {
  var text = getNameSpacedAction(actionName);
  var methodCallMatchesPluginNamespace = text && text.name === pluginName;

  if (methodCallMatchesPluginNamespace) {
    var sub = getNameSpacedAction(text.method);
    var subText = sub ? 'or ' + sub.method : '';
    throw new Error([pluginName + ' plugin is calling method ' + actionName, 'Plugins cant call self', "Use ".concat(text.method, " ").concat(subText, " in ").concat(pluginName, " plugin insteadof ").concat(actionName)].join('\n'));
  }
}

function getNameSpacedAction(event) {
  var split = event.match(/(.*):(.*)/);

  if (!split) {
    return false;
  }

  return {
    method: split[1],
    name: split[2]
  };
}

function formatPayload(action) {
  return Object.keys(action).reduce(function (acc, key) {
    // redact type from { payload }
    if (key === 'type') {
      return acc;
    }

    if (analyticsUtils.isObject(action[key])) {
      acc[key] = Object.assign({}, action[key]);
    } else {
      acc[key] = action[key];
    }

    return acc;
  }, {});
}
/*
function getMatchingMethods(eventType, activePlugins) {
  const exact = getPluginFunctions(eventType, activePlugins)
  // console.log('exact', exact)
  // Gather nameSpaced Events
  return activePlugins.reduce((acc, plugin) => {
    const { name } = plugin
    const clean = getPluginFunctions(`${eventType}:${name}`, activePlugins)
    if (clean.length) {
      acc.namespaced[name] = clean
    }
    return acc
  }, {
    exact: exact,
    namespaced: {}
  })
}
*/

function pluginMiddleware(instance, getPlugins, systemEvents) {
  var isReady = {};
  return function (store) {
    return function (next) {
      return (
        /*#__PURE__*/
        function () {
          var _ref = asyncToGenerator(
          /*#__PURE__*/
          regenerator.mark(function _callee(action) {
            var type, abort, plugins, updatedAction, allPlugins, pluginsArray, allRegisteredPlugins, completed, failed, disabled, waitForPluginsToLoad, updated;
            return regenerator.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    type = action.type, abort = action.abort, plugins = action.plugins;
                    updatedAction = action;

                    if (!abort) {
                      _context.next = 4;
                      break;
                    }

                    return _context.abrupt("return", next(action));

                  case 4:
                    /* Analytics.plugins.enable called, we need to init the plugins */
                    if (type === EVENTS.enablePlugin) {
                      store.dispatch({
                        type: EVENTS.initializeStart,
                        plugins: plugins,
                        disabled: [],
                        fromEnable: true,
                        meta: action.meta
                      });
                    }

                    if (type === EVENTS.disablePlugin) {
                      // If cached callback, resolve promise/run callback. debounced to fix race condition
                      setTimeout(function () {
                        return runCallback(action.meta.rid, {
                          payload: action
                        });
                      }, 0);
                    }
                    /* @TODO implement
                    if (type === EVENTS.loadPlugin) {
                      // Rerun initialize calls in plugins
                      const allPlugins = getPlugins()
                      const pluginsToLoad = Object.keys(allPlugins).filter((name) => {
                        return plugins.includes(name)
                      }).reduce((acc, curr) => {
                        acc[curr] = allPlugins[curr]
                        return acc
                      }, {})
                      const initializeAction = {
                        type: EVENTS.initializeStart,
                        plugins: plugins
                      }
                      const updated = await runPlugins(initializeAction, pluginsToLoad, instance, store, systemEvents)
                      return next(updated)
                    }
                    */
                    //*  || type.match(/^initializeAbort:/)


                    if (type === EVENTS.initializeEnd) {
                      allPlugins = getPlugins();
                      pluginsArray = Object.keys(allPlugins);
                      allRegisteredPlugins = pluginsArray.filter(function (name) {
                        return plugins.includes(name);
                      }).map(function (name) {
                        return allPlugins[name];
                      });
                      completed = [];
                      failed = [];
                      disabled = action.disabled; // console.log('allRegisteredPlugins', allRegisteredPlugins)

                      waitForPluginsToLoad = allRegisteredPlugins.map(function (plugin) {
                        var loaded = plugin.loaded,
                            name = plugin.name;
                        /* Plugins will abort trying to load after 10 seconds. 1e4 === 10000 MS */

                        return waitForReady(plugin, loaded, 1e4).then(function (d) {
                          if (!isReady[name]) {
                            // only dispatch namespaced rdy once
                            store.dispatch({
                              type: EVENTS.pluginReadyType(name),
                              // `ready:${name}`
                              name: name,
                              events: Object.keys(plugin).filter(function (name) {
                                return !nonEvents.includes(name);
                              })
                            });
                            isReady[name] = true;
                          }

                          completed = completed.concat(name);
                          return plugin; // It's loaded! run the command
                        })["catch"](function (e) {
                          // Timeout Add to queue
                          // console.log('Error generic waitForReady. Push this to queue', e)
                          if (e instanceof Error) {
                            throw new Error(e);
                          }

                          failed = failed.concat(e.name); // Failed to fire, add to queue

                          return e;
                        });
                      });
                      Promise.all(waitForPluginsToLoad).then(function (calls) {
                        // setTimeout to ensure runs after 'page'
                        var payload = {
                          plugins: completed,
                          failed: failed,
                          disabled: disabled
                        };
                        setTimeout(function () {
                          if (pluginsArray.length === waitForPluginsToLoad.length + disabled.length) {
                            store.dispatch(objectSpread2(objectSpread2({}, {
                              type: EVENTS.ready
                            }), payload));
                          }
                        }, 0);
                      });
                    }
                    /* New plugin system */


                    if (!(type !== EVENTS.bootstrap)) {
                      _context.next = 13;
                      break;
                    }

                    if (/^ready:([^:]*)$/.test(type)) {
                      // Immediately flush queue
                      setTimeout(function () {
                        return processQueue(store, getPlugins, instance);
                      }, 0);
                    }

                    _context.next = 11;
                    return runPlugins(action, getPlugins, instance, store, systemEvents);

                  case 11:
                    updated = _context.sent;
                    return _context.abrupt("return", next(updated));

                  case 13:
                    return _context.abrupt("return", next(updatedAction));

                  case 14:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          return function (_x) {
            return _ref.apply(this, arguments);
          };
        }()
      );
    };
  };
}

function storageMiddleware(storage) {
  return function (store) {
    return function (next) {
      return function (action) {
        var type = action.type,
            key = action.key,
            value = action.value,
            options = action.options;

        if (type === EVENTS.setItem || type === EVENTS.removeItem) {
          if (action.abort) {
            return next(action);
          } // Run storage set or remove


          if (type === EVENTS.setItem) {
            storage.setItem(key, value, options);
          } else {
            storage.removeItem(key, options);
          }
        }

        return next(action);
      };
    };
  };
}
/*
  Todo: emit events for keys we care about
  window.addEventListener('storage', (event) => console.log(event));
*/

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var classCallCheck = _classCallCheck;

/* Class to fix dynamic middlewares from conflicting with each other
if more than one analytic instance is active */

var DynamicMiddleware = function DynamicMiddleware() {
  var _this = this;

  classCallCheck(this, DynamicMiddleware);

  defineProperty(this, "before", []);

  defineProperty(this, "after", []);

  defineProperty(this, "addMiddleware", function (middlewares, position) {
    _this[position] = _this[position].concat(middlewares);
  });

  defineProperty(this, "removeMiddleware", function (middleware, position) {
    var index = _this[position].findIndex(function (d) {
      return d === middleware;
    });

    if (index === -1) return;
    _this[position] = [].concat(toConsumableArray(_this[position].slice(0, index)), toConsumableArray(_this[position].slice(index + 1)));
  });

  defineProperty(this, "dynamicMiddlewares", function (position) {
    return function (store) {
      return function (next) {
        return function (action) {
          var middlewareAPI = {
            getState: store.getState,
            dispatch: function dispatch(act) {
              return store.dispatch(act);
            }
          };

          var chain = _this[position].map(function (middleware) {
            return middleware(middlewareAPI);
          });

          return compose.apply(void 0, toConsumableArray(chain))(next)(action);
        };
      };
    };
  });
};

function createReducer(getPlugins) {
  return function plugins() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = arguments.length > 1 ? arguments[1] : undefined;
    var newState = {};

    if (action.type === 'initialize:aborted') {
      return state;
    }

    if (/^registerPlugin:([^:]*)$/.test(action.type)) {
      var name = getNameFromEventType(action.type, 'registerPlugin');
      var plugin = getPlugins()[name];

      if (!plugin || !name) {
        return state;
      }

      var isEnabled = action.enabled;
      newState[name] = {
        enabled: isEnabled,

        /* if no initialization method. Set initialized true */
        initialized: isEnabled ? Boolean(!plugin.initialize) : false,

        /* If plugin enabled === false, set loaded to false, else check plugin.loaded function */
        loaded: isEnabled ? Boolean(plugin.loaded()) : false,
        config: plugin.config || {}
      };
      return objectSpread2(objectSpread2({}, state), newState);
    }

    if (/^initialize:([^:]*)$/.test(action.type)) {
      var _name = getNameFromEventType(action.type, EVENTS.initialize);

      var _plugin = getPlugins()[_name];

      if (!_plugin || !_name) {
        return state;
      }

      newState[_name] = objectSpread2(objectSpread2({}, state[_name]), {
        initialized: true,

        /* check plugin.loaded function */
        loaded: Boolean(_plugin.loaded())
      });
      return objectSpread2(objectSpread2({}, state), newState);
    }

    if (/^ready:([^:]*)$/.test(action.type)) {
      // const name = getNameFromEventType(action.type, 'ready')
      newState[action.name] = objectSpread2(objectSpread2({}, state[action.name]), {
        loaded: true
      });
      return objectSpread2(objectSpread2({}, state), newState);
    }

    switch (action.type) {
      /* case EVENTS.pluginFailed:
        // console.log('PLUGIN_FAILED', action.name)
        newState[action.name] = {
          ...state[action.name],
          ...{ loaded: false }
        }
        return { ...state, ...newState }
      */

      /* When analytics.plugins.disable called */
      case EVENTS.disablePlugin:
        return objectSpread2(objectSpread2({}, state), togglePluginStatus(action.plugins, false, state));

      /* When analytics.plugins.enable called */

      case EVENTS.enablePlugin:
        return objectSpread2(objectSpread2({}, state), togglePluginStatus(action.plugins, true, state));

      default:
        return state;
    }
  };
}

function getNameFromEventType(type, baseName) {
  return type.substring(baseName.length + 1, type.length);
}

function togglePluginStatus(plugins, status, currentState) {
  return plugins.reduce(function (acc, pluginKey) {
    acc[pluginKey] = objectSpread2(objectSpread2({}, currentState[pluginKey]), {
      enabled: status
    });
    return acc;
  }, currentState);
}

// TODO fix os. os getting stripped out for node build

function getBrowserOS() {
  if (!analyticsUtils.inBrowser) return false;
  var os = navigator.appVersion; // ~os bitwise operator to check if in navigator

  if (~os.indexOf('Win')) return 'Windows';
  if (~os.indexOf('Mac')) return 'MacOS';
  if (~os.indexOf('X11')) return 'UNIX';
  if (~os.indexOf('Linux')) return 'Linux'; // default

  return 'Unknown OS';
}

var osName;
var referrer;
var locale;
var timeZone;

{
  osName = getBrowserOS();
  referrer = analyticsUtils.inBrowser ? document.referrer : null;
  locale = analyticsUtils.getBrowserLocale();
  timeZone = analyticsUtils.getTimeZone();
}

var initialState = {
  initialized: false,
  sessionId: analyticsUtils.uuid(),
  app: null,
  version: null,
  debug: false,
  offline: analyticsUtils.inBrowser ? !navigator.onLine : false,
  // use node network is-online
  os: {
    name: osName
  },
  userAgent: analyticsUtils.inBrowser ? navigator.userAgent : 'node',
  // https://github.com/bestiejs/platform.js
  library: {
    name: LIBRARY_NAME,
    // TODO fix version number. npm run publish:patch has wrong version
    version: "0.10.4"
  },
  timezone: timeZone,
  locale: locale,
  campaign: {},
  referrer: referrer // context reducer

};
function context() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  var initialized = state.initialized;
  var type = action.type,
      campaign = action.campaign;

  switch (type) {
    case EVENTS.campaign:
      return objectSpread2(objectSpread2({}, state), {
        campaign: campaign
      });

    case EVENTS.offline:
      return objectSpread2(objectSpread2({}, state), {
        offline: true
      });

    case EVENTS.online:
      return objectSpread2(objectSpread2({}, state), {
        offline: false
      });

    default:
      if (!initialized) {
        return objectSpread2(objectSpread2(objectSpread2({}, initialState), state), {
          initialized: true
        });
      }

      return state;
  }
}
var excludeItems = ['plugins', 'reducers', 'storage']; // Pull plugins and reducers off intital config

function makeContext(config) {
  return Object.keys(config).reduce(function (acc, current) {
    if (excludeItems.includes(current)) {
      return acc;
    }

    acc[current] = config[current];
    return acc;
  }, {});
}

function serialize(obj) {
  var s = obj;

  try {
    s = JSON.parse(JSON.stringify(obj));
  } catch (err) {}

  return s;
}

var hashRegex = /#.*$/;

function canonicalUrl() {
  if (!analyticsUtils.inBrowser) return;
  var tags = document.getElementsByTagName('link');

  for (var i = 0, tag; tag = tags[i]; i++) {
    if (tag.getAttribute('rel') === 'canonical') {
      return tag.getAttribute('href');
    }
  }
}

function urlPath(url) {
  var regex = /(http[s]?:\/\/)?([^\/\s]+\/)(.*)/g;
  var matches = regex.exec(url);
  var pathMatch = matches && matches[3] ? matches[3].split('?')[0].replace(hashRegex, '') : '';
  return '/' + pathMatch;
}
/**
 * Return the canonical URL and rmove the hash.
 * @param  {string} search - search param
 * @return {string} return current canonical URL
 */


function currentUrl(search) {
  var canonical = canonicalUrl();
  if (!canonical) return window.location.href.replace(hashRegex, '');
  return canonical.match(/\?/) ? canonical : canonical + search;
}
/**
 * Page data for overides
 * @typedef {object} PageData
 * @property {string} [title] - Page title
 * @property {string} [url] - Page url
 * @property {string} [path] - Page path
 * @property {string} [search] - Page search
 * @property {string} [width] - Page width
 * @property {string} [height] - Page height
*/

/**
 * Get information about current page
 * @typedef {Function} getPageData
 * @param  {PageData} [pageData = {}] - Page data overides
 * @return {PageData} resolved page data
 */


var getPageData = function getPageData() {
  var pageData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  if (!analyticsUtils.inBrowser) return pageData;
  var _document = document,
      title = _document.title,
      referrer = _document.referrer;
  var _window = window,
      location = _window.location,
      innerWidth = _window.innerWidth,
      innerHeight = _window.innerHeight;
  var hash = location.hash,
      search = location.search;
  var url = currentUrl(search);
  var page = {
    title: title,
    url: url,
    path: urlPath(url),
    hash: hash,
    search: search,
    width: innerWidth,
    height: innerHeight
  };

  if (referrer && referrer !== '') {
    page.referrer = referrer;
  }

  return objectSpread2(objectSpread2({}, page), pageData);
};
var initialState$1 = {
  last: {},
  history: [] // page reducer

};
function page() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState$1;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  var properties = action.properties,
      options = action.options,
      meta = action.meta;

  switch (action.type) {
    case EVENTS.page:
      var viewData = serialize(objectSpread2({
        properties: properties,
        meta: meta
      }, Object.keys(options).length && {
        options: options
      }));
      return objectSpread2(objectSpread2({}, state), {
        last: viewData,
        // Todo prevent LARGE arrays https://bit.ly/2MnBwPT
        history: state.history.concat(viewData)
      });

    default:
      return state;
  }
}

var initialState$2 = {
  last: {},
  history: [] // track reducer

};
function trackReducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState$2;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  var type = action.type,
      meta = action.meta,
      options = action.options,
      event = action.event,
      properties = action.properties;

  switch (type) {
    case EVENTS.track:
      var trackEvent = serialize(objectSpread2(objectSpread2({
        event: event,
        properties: properties
      }, Object.keys(options).length && {
        options: options
      }), {}, {
        meta: meta
      }));
      return objectSpread2(objectSpread2({}, state), {
        last: trackEvent,
        // Todo prevent LARGE arrays https://bit.ly/2MnBwPT
        history: state.history.concat(trackEvent)
      });
    // todo push events to history

    default:
      return state;
  }
}

/*
TODO figure out if this should live in state...
Queue could be in mermory as well.
But also needs to be persisted to storage
*/

var initialState$3 = {
  actions: []
};
function queueReducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState$3;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  var type = action.type,
      payload = action.payload;

  switch (type) {
    case 'queue':
      var actionChain;
      /* prioritize identify in event queue */

      if (payload && payload.type && payload.type === EVENTS.identify) {
        actionChain = [action].concat(state.actions);
      } else {
        actionChain = state.actions.concat(action);
      }

      return objectSpread2(objectSpread2({}, state), {}, {
        actions: actionChain
      });

    case 'dequeue':
      return [];
    // todo push events to history

    default:
      return state;
  }
}

function listen(events, func, toAdd) {
  if (!analyticsUtils.inBrowser) return false;
  var fn = window[(toAdd ? 'add' : 'remove') + 'EventListener'];
  events.split(' ').forEach(function (ev) {
    fn(ev, func);
  });
}

function check() {
  return Promise.resolve(!navigator.onLine);
}
function watch(cb) {
  var fn = function fn(_) {
    return check().then(cb);
  };

  var listener = listen.bind(null, 'online offline', fn);
  listener(true); // return unsubscribe

  return function (_) {
    return listener(false);
  };
}

function Debug() {
  // initialize global history

  var globalVariable = PREFIX + LIBRARY_NAME + PREFIX; // Global key is window.__analytics__

  analyticsUtils.globalContext[globalVariable] = [];
  return function (createStore$$1) {
    return function (reducer, preloadedState, enhancer) {
      var store = createStore$$1(reducer, preloadedState, enhancer);
      var origDispatch = store.dispatch;

      var dispatch = function dispatch(action) {
        var a = action.action || action;
        analyticsUtils.globalContext[globalVariable].push(a);
        return origDispatch(action);
      };

      return Object.assign(store, {
        dispatch: dispatch
      });
    };
  };
}
function composeWithDebug(config) {
  return function () {
    return compose(compose.apply(null, arguments), Debug(config));
  };
}

function ensureArray(singleOrArray) {
  if (!singleOrArray) return [];
  if (analyticsUtils.isArray(singleOrArray)) return singleOrArray;
  return [singleOrArray];
}

function getCallbackFromArgs(argArray) {
  var processArray = argArray || Array.prototype.slice.call(arguments);
  return processArray.reduce(function (acc, arg) {
    if (acc) return acc;

    if (analyticsUtils.isFunction(arg)) {
      return arg;
    }

    return acc;
  }, false);
}

function timeStamp() {
  return new Date().getTime();
}

function deferredPromiseResolver(resolver, callback) {
  return function (data) {
    if (callback) callback(data);
    resolver(data);
  };
}

function generateMeta() {
  var meta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var resolve = arguments.length > 1 ? arguments[1] : undefined;
  var possibleCallbacks = arguments.length > 2 ? arguments[2] : undefined;
  var rid = analyticsUtils.uuid();

  if (resolve) {
    // stack[`${rid}-info`] = meta
    stack[rid] = deferredPromiseResolver(resolve, getCallbackFromArgs(possibleCallbacks));
  }

  return objectSpread2(objectSpread2({}, meta), {}, {
    rid: rid,
    ts: timeStamp()
  }, !resolve ? {} : {
    hasCallback: true
  });
}

/**
 * Analytics library configuration
 *
 * After the library is initialized with config, the core API is exposed & ready for use in the application.
 *
 * @param {object} config - analytics core config
 * @param {string} [config.app] - Name of site / app
 * @param {string} [config.version] - Version of your app
 * @param {boolean} [config.debug] - Should analytics run in debug mode
 * @param {Array.<AnalyticsPlugin>}  [config.plugins] - Array of analytics plugins
 * @return {AnalyticsInstance} Analytics Instance
 * @example
 *
 * import Analytics from 'analytics'
 * import pluginABC from 'analytics-plugin-abc'
 * import pluginXYZ from 'analytics-plugin-xyz'
 *
 * // initialize analytics
 * const analytics = Analytics({
 *   app: 'my-awesome-app',
 *   plugins: [
 *     pluginABC,
 *     pluginXYZ
 *   ]
 * })
 *
 */

function analytics() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var customReducers = config.reducers || {};
  var initialUser = config.initialUser || {}; // @TODO add custom value reolvers for userId and anonId
  // const resolvers = config.resolvers || {}

  /* Parse plugins array */

  var parsedOptions = (config.plugins || []).reduce(function (acc, plugin) {
    if (analyticsUtils.isFunction(plugin)) {
      /* Custom redux middleware */
      acc.middlewares = acc.middlewares.concat(plugin);
      return acc;
    } // Legacy plugin with name


    if (plugin.NAMESPACE) plugin.name = plugin.NAMESPACE;

    if (!plugin.name) {
      /* Plugins must supply a "name" property. See error url for more details */
      throw new Error(ERROR_URL + '1');
    } // if plugin exposes EVENTS capture available events


    var definedEvents = plugin.EVENTS ? Object.keys(plugin.EVENTS).map(function (k) {
      return plugin.EVENTS[k];
    }) : [];
    var enabledFromMerge = !(plugin.enabled === false);
    var enabledFromPluginConfig = !(plugin.config && plugin.config.enabled === false); // top level { enabled: false } takes presidence over { config: enabled: false }

    acc.pluginEnabled[plugin.name] = enabledFromMerge && enabledFromPluginConfig;
    delete plugin.enabled;

    if (plugin.methods) {
      acc.methods[plugin.name] = Object.keys(plugin.methods).reduce(function (a, c) {
        // enrich methods with analytics instance
        a[c] = appendArguments(plugin.methods[c]);
        return a;
      }, {}); // Remove additional methods from plugins

      delete plugin.methods;
    } // Convert available methods into events


    var methodsToEvents = Object.keys(plugin); // Combine events

    var allEvents = methodsToEvents.concat(definedEvents); // Dedupe events list

    var allEventsUnique = new Set(acc.events.concat(allEvents));
    acc.events = Array.from(allEventsUnique);
    acc.pluginsArray = acc.pluginsArray.concat(plugin);

    if (acc.plugins[plugin.name]) {
      throw new Error(plugin.name + 'AlreadyLoaded');
    }

    acc.plugins[plugin.name] = plugin;

    if (!acc.plugins[plugin.name].loaded) {
      // set default loaded func
      acc.plugins[plugin.name].loaded = function () {
        return true;
      };
    }

    return acc;
  }, {
    plugins: {},
    pluginEnabled: {},
    methods: {},
    pluginsArray: [],
    middlewares: [],
    events: []
  });
  /* Storage by default is set to global & is not persisted */

  var storage = config.storage ? config.storage : {
    getItem: function getItem(key) {
      return analyticsUtils.globalContext[key];
    },
    setItem: function setItem(key, value) {
      return analyticsUtils.globalContext[key] = value;
    },
    removeItem: function removeItem(key) {
      return analyticsUtils.globalContext[key] = undefined;
    }
  };
  var getUserProp = getUserPropFunc(storage); // mutable intregrations object for dynamic loading

  var customPlugins = parsedOptions.plugins;
  /* Grab all registered events from plugins loaded */

  var pluginEvents = parsedOptions.events.filter(function (name) {
    return !nonEvents.includes(name);
  });
  var uniqueEvents = new Set(pluginEvents.concat(coreEvents).filter(function (name) {
    return !nonEvents.includes(name);
  }));
  var allSystemEvents = Array.from(uniqueEvents).sort();
  var allPluginEvents = pluginEvents.sort();
  /* plugin methods(functions) must be kept out of state. thus they live here */

  var getPlugins = function getPlugins() {
    return customPlugins;
  };

  var _ref = new DynamicMiddleware(),
      addMiddleware = _ref.addMiddleware,
      removeMiddleware = _ref.removeMiddleware,
      dynamicMiddlewares = _ref.dynamicMiddlewares;

  var nonAbortable = function nonAbortable() {
    // throw new Error(`${ERROR_URL}3`)
    throw new Error('Abort disabled inListener');
  }; // Parse URL parameters


  var params = analyticsUtils.paramsParse(); // Initialize visitor information

  var persistedUser = getPersistedUserData(storage);

  var visitorInfo = objectSpread2(objectSpread2(objectSpread2(objectSpread2({}, persistedUser), initialUser), !params.an_uid ? {} : {
    userId: params.an_uid
  }), !params.an_aid ? {} : {
    anonymousId: params.an_aid
  }); // If no anon id set, create one


  if (!visitorInfo.anonymousId) {
    visitorInfo.anonymousId = analyticsUtils.uuid();
  } // TODO merge and set traits

  /**
   * Async Management methods for plugins. 
   * 
   * This is also where [custom methods](https://bit.ly/329vFXy) are loaded into the instance.
   * @typedef {Object} Plugins
   * @property {EnablePlugin} enable - Set storage value
   * @property {DisablePlugin} disable - Remove storage value
   * @example
   *
   * // Enable a plugin by namespace
   * analytics.plugins.enable('keenio')
   *
   * // Disable a plugin by namespace
   * analytics.plugins.disable('google-analytics')
   */


  var plugins = objectSpread2({
    /**
     * Enable analytics plugin
     * @typedef {Function} EnablePlugin
     * @param  {String|Array} plugins - name of plugins(s) to disable
     * @param  {Function} [callback] - callback after enable runs
     * @returns {Promise}
     * @example
     *
     * analytics.plugins.enable('google-analytics').then(() => {
     *   console.log('do stuff')
     * })
     *
     * // Enable multiple plugins at once
     * analytics.plugins.enable(['google-analytics', 'segment']).then(() => {
     *   console.log('do stuff')
     * })
     */
    enable: function enable(plugins, callback) {
      return new Promise(function (resolve) {
        store.dispatch({
          type: EVENTS.enablePlugin,
          plugins: ensureArray(plugins),
          _: {
            originalAction: EVENTS.enablePlugin
          }
        }, resolve, [callback]);
      });
    },

    /**
     * Disable analytics plugin
     * @typedef {Function} DisablePlugin
     * @param  {String|Array} plugins - name of integration(s) to disable
     * @param  {Function} callback - callback after disable runs
     * @returns {Promise}
     * @example
     *
     * analytics.plugins.disable('google').then(() => {
     *   console.log('do stuff')
     * })
     *
     * analytics.plugins.disable(['google', 'segment']).then(() => {
     *   console.log('do stuff')
     * })
     */
    disable: function disable(plugins, callback) {
      return new Promise(function (resolve) {
        store.dispatch({
          type: EVENTS.disablePlugin,
          plugins: ensureArray(plugins),
          _: {
            originalAction: EVENTS.disablePlugin
          }
        }, resolve, [callback]);
      });
    }
  }, parsedOptions.methods);
  /**
   * Analytic instance returned from initialization
   * @typedef {Object} AnalyticsInstance
   * @property {Identify} identify - Identify a user
   * @property {Track} track - Track an analytics event
   * @property {Page} page - Trigger page view
   * @property {User} user - Get user data
   * @property {Reset} reset - Clear information about user & reset analytics
   * @property {Ready} ready - Fire callback on analytics ready event
   * @property {On} on - Fire callback on analytics lifecycle events.
   * @property {Once} once - Fire callback on analytics lifecycle events once.
   * @property {GetState} getState - Get data about user, activity, or context.
   * @property {Storage} storage - storage methods
   * @property {Plugins} plugins - plugin methods
   */


  var instance = {
    /**
    * Identify a user. This will trigger `identify` calls in any installed plugins and will set user data in localStorage
    * @typedef {Function} Identify
    * @param  {String}   userId  - Unique ID of user
    * @param  {Object}   [traits]  - Object of user traits
    * @param  {Object}   [options] - Options to pass to identify call
    * @param  {Function} [callback] - Callback function after identify completes
    * @returns {Promise}
    * @api public
    *
    * @example
    *
    * // Basic user id identify
    * analytics.identify('xyz-123')
    *
    * // Identify with additional traits
    * analytics.identify('xyz-123', {
    *   name: 'steve',
    *   company: 'hello-clicky'
    * })
    *
    * // Fire callback with 2nd or 3rd argument
    * analytics.identify('xyz-123', () => {
    *   console.log('do this after identify')
    * })
    *
    * // Disable sending user data to specific analytic tools
    * analytics.identify('xyz-123', {}, {
    *   plugins: {
    *     // disable sending this identify call to segment
    *     segment: false
    *   }
    * })
    *
    * // Send user data to only to specific analytic tools
    * analytics.identify('xyz-123', {}, {
    *   plugins: {
    *     // disable this specific identify in all plugins except customerio
    *     all: false,
    *     customerio: true
    *   }
    * })
    */
    identify: function () {
      var _identify = asyncToGenerator(
      /*#__PURE__*/
      regenerator.mark(function _callee(userId, traits, options, callback) {
        var id, data, opts, user, resolvedId;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                id = analyticsUtils.isString(userId) ? userId : null;
                data = analyticsUtils.isObject(userId) ? userId : traits;
                opts = options || {};
                user = instance.user();
                /* sets temporary in memory id. Not to be relied on */

                analyticsUtils.globalContext[tempKey(ID)] = id;
                resolvedId = id || data.userId || getUserProp(ID, instance, data);
                return _context.abrupt("return", new Promise(function (resolve) {
                  store.dispatch(objectSpread2({
                    type: EVENTS.identifyStart,
                    userId: resolvedId,
                    traits: data || {},
                    options: opts,
                    anonymousId: user.anonymousId
                  }, user.id && user.id !== id && {
                    previousId: user.id
                  }), resolve, [traits, options, callback]);
                }));

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function identify(_x, _x2, _x3, _x4) {
        return _identify.apply(this, arguments);
      }

      return identify;
    }(),

    /**
     * Track an analytics event. This will trigger `track` calls in any installed plugins
     * @typedef {Function} Track
     * @param  {String}   eventName - Event name
     * @param  {Object}   [payload]   - Event payload
     * @param  {Object}   [options]   - Event options
     * @param  {Function} [callback]  - Callback to fire after tracking completes
     * @returns {Promise}
     * @api public
     *
     * @example
     *
     * // Basic event tracking
     * analytics.track('buttonClicked')
     *
     * // Event tracking with payload
     * analytics.track('itemPurchased', {
     *   price: 11,
     *   sku: '1234'
     * })
     *
     * // Fire callback with 2nd or 3rd argument
     * analytics.track('newsletterSubscribed', () => {
     *   console.log('do this after track')
     * })
     *
     * // Disable sending this event to specific analytic tools
     * analytics.track('cartAbandoned', {
     *   items: ['xyz', 'abc']
     * }, {
     *   plugins: {
     *     // disable track event for segment
     *     segment: false
     *   }
     * })
     *
     * // Send event to only to specific analytic tools
     * analytics.track('customerIoOnlyEventExample', {
     *   price: 11,
     *   sku: '1234'
     * }, {
     *   plugins: {
     *     // disable this specific track call all plugins except customerio
     *     all: false,
     *     customerio: true
     *   }
     * })
     */
    track: function () {
      var _track = asyncToGenerator(
      /*#__PURE__*/
      regenerator.mark(function _callee2(eventName, payload, options, callback) {
        var name, data, opts;
        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                name = analyticsUtils.isObject(eventName) ? eventName.event : eventName;

                if (!(!name || !analyticsUtils.isString(name))) {
                  _context2.next = 3;
                  break;
                }

                throw new Error('EventMissing');

              case 3:
                data = analyticsUtils.isObject(eventName) ? eventName : payload || {};
                opts = analyticsUtils.isObject(options) ? options : {};
                return _context2.abrupt("return", new Promise(function (resolve) {
                  store.dispatch({
                    type: EVENTS.trackStart,
                    event: name,
                    properties: data,
                    options: opts,
                    userId: getUserProp(ID, instance, payload),
                    anonymousId: getUserProp(ANONID, instance, payload)
                  }, resolve, [payload, options, callback]);
                }));

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function track(_x5, _x6, _x7, _x8) {
        return _track.apply(this, arguments);
      }

      return track;
    }(),

    /**
     * Trigger page view. This will trigger `page` calls in any installed plugins
     * @typedef {Function} Page
     * @param  {PageData} [data] - Page data overrides.
     * @param  {Object}   [options] - Page tracking options
     * @param  {Function} [callback] - Callback to fire after page view call completes
     * @returns {Promise}
     * @api public
     *
     * @example
     *
     * // Basic page tracking
     * analytics.page()
     *
     * // Page tracking with page data overrides
     * analytics.page({
     *   url: 'https://google.com'
     * })
     *
     * // Fire callback with 1st, 2nd or 3rd argument
     * analytics.page(() => {
     *   console.log('do this after page')
     * })
     *
     * // Disable sending this pageview to specific analytic tools
     * analytics.page({}, {
     *   plugins: {
     *     // disable page tracking event for segment
     *     segment: false
     *   }
     * })
     *
     * // Send pageview to only to specific analytic tools
     * analytics.page({}, {
     *   plugins: {
     *     // disable this specific page in all plugins except customerio
     *     all: false,
     *     customerio: true
     *   }
     * })
     */
    page: function () {
      var _page = asyncToGenerator(
      /*#__PURE__*/
      regenerator.mark(function _callee3(data, options, callback) {
        var d, opts;
        return regenerator.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                d = analyticsUtils.isObject(data) ? data : {};
                opts = analyticsUtils.isObject(options) ? options : {};
                /*
                // @TODO add custom value reolvers for userId and anonId
                if (resolvers.getUserId) {
                  const asyncUserId = await resolvers.getUserId()
                  console.log('x', x)
                }
                */

                return _context3.abrupt("return", new Promise(function (resolve, reject) {
                  store.dispatch({
                    type: EVENTS.pageStart,
                    properties: getPageData(d),
                    options: opts,
                    userId: getUserProp(ID, instance, d),
                    anonymousId: getUserProp(ANONID, instance, d)
                  }, resolve, [data, options, callback]);
                }));

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function page$$1(_x9, _x10, _x11) {
        return _page.apply(this, arguments);
      }

      return page$$1;
    }(),

    /**
     * Get user data
     * @typedef {Function} User
     * @param {string} [key] - dot.prop.path of user data. Example: 'traits.company.name'
     * @returns {string|object} value of user data or null
     *
     * @example
     *
     * // Get all user data
     * const userData = analytics.user()
     *
     * // Get user id
     * const userId = analytics.user('userId')
     *
     * // Get user company name
     * const companyName = analytics.user('traits.company.name')
     */
    user: function user(key) {
      if (key === ID || key === 'id') {
        return getUserProp(ID, instance);
      }

      if (key === ANONID || key === 'anonId') {
        return getUserProp(ANONID, instance);
      }

      var user = instance.getState('user');
      if (!key) return user;
      return analyticsUtils.dotProp(user, key);
    },

    /**
     * Clear all information about the visitor & reset analytic state.
     * @typedef {Function} Reset
     * @param {Function} [callback] - Handler to run after reset
     * @returns {Promise}
     * @example
     *
     * // Reset current visitor
     * analytics.reset()
     */
    reset: function reset(callback) {
      return new Promise(function (resolve, reject) {
        store.dispatch({
          type: EVENTS.resetStart
        }, resolve, callback);
      });
    },

    /**
     * Fire callback on analytics ready event
     * @typedef {Function} Ready
     * @param  {Function} callback - function to trigger when all providers have loaded
     * @returns {DetachListeners} - Function to detach listener
     *
     * @example
     *
     * analytics.ready() => {
     *   console.log('all plugins have loaded or were skipped', payload)
     * })
     */
    ready: function ready(callback) {
      return instance.on(EVENTS.ready, callback);
    },

    /**
     * Attach an event handler function for analytics lifecycle events.
     * @typedef {Function} On
     * @param  {String}   name - Name of event to listen to
     * @param  {Function} callback - function to fire on event
     * @return {DetachListeners} - Function to detach listener
     *
     * @example
     *
     * // Fire function when 'track' calls happen
     * analytics.on('track', ({ payload }) => {
     *   console.log('track call just happened. Do stuff')
     * })
     *
     * // Remove listener before it is called
     * const removeListener = analytics.on('track', ({ payload }) => {
     *   console.log('This will never get called')
     * })
     *
     * // cleanup .on listener
     * removeListener()
     */
    on: function on(name, callback) {
      if (!name || !analyticsUtils.isFunction(callback)) {
        return false;
      }

      if (name === EVENTS.bootstrap) {
        throw new Error('.on disabled for ' + name);
      }

      var startRegex = /Start$|Start:/;

      if (name === '*') {
        var beforeHandler = function beforeHandler(store) {
          return function (next) {
            return function (action) {
              if (action.type.match(startRegex)) {
                callback({
                  // eslint-disable-line
                  payload: action,
                  instance: instance,
                  plugins: customPlugins
                });
              }

              return next(action);
            };
          };
        };

        var afterHandler = function afterHandler(store) {
          return function (next) {
            return function (action) {
              if (!action.type.match(startRegex)) {
                callback({
                  // eslint-disable-line
                  payload: action,
                  instance: instance,
                  plugins: customPlugins
                });
              }

              return next(action);
            };
          };
        };

        addMiddleware(beforeHandler, before);
        addMiddleware(afterHandler, after);
        /**
         * Detach listeners
         * @typedef {Function} DetachListeners
         */

        return function () {
          removeMiddleware(beforeHandler, before);
          removeMiddleware(afterHandler, after);
        };
      }

      var position = name.match(startRegex) ? before : after; // eslint-disable-line

      var handler = function handler(store) {
        return function (next) {
          return function (action) {
            // Subscribe to EVERYTHING
            if (action.type === name) {
              callback({
                // eslint-disable-line
                payload: action,
                instance: instance,
                plugins: customPlugins,
                abort: nonAbortable
              });
            }
            /* For future matching of event subpaths `track:*` etc
            } else if (name.match(/\*$/)) {
              const match = (name === '*') ? '.' : name
              const regex = new RegExp(`${match}`, 'g')
            } */


            return next(action);
          };
        };
      };

      addMiddleware(handler, position);
      return function () {
        return removeMiddleware(handler, position);
      };
    },

    /**
     * Attach a handler function to an event and only trigger it only once.
     * @typedef {Function} Once
     * @param  {String} name - Name of event to listen to
     * @param  {Function} callback - function to fire on event
     * @return {DetachListeners} - Function to detach listener
     *
     * @example
     *
     * // Fire function only once 'track'
     * analytics.once('track', ({ payload }) => {
     *   console.log('This will only triggered once when analytics.track() fires')
     * })
     *
     * // Remove listener before it is called
     * const listener = analytics.once('track', ({ payload }) => {
     *   console.log('This will never get called b/c listener() is called')
     * })
     *
     * // cleanup .once listener before it fires
     * listener()
     */
    once: function once(name, callback) {
      if (!name || !analyticsUtils.isFunction(callback)) {
        return false;
      }

      if (name === EVENTS.bootstrap) {
        throw new Error('.once disabled for ' + name);
      }

      var detachListener = instance.on(name, function (_ref2) {
        var payload = _ref2.payload;
        callback({
          // eslint-disable-line
          payload: payload,
          instance: instance,
          plugins: customPlugins,
          abort: nonAbortable
        }); // detach listener after its called once

        detachListener();
      });
      return detachListener;
    },

    /**
     * Get data about user, activity, or context. Access sub-keys of state with `dot.prop` syntax.
     * @typedef {Function} GetState
     * @param  {string} [key] - dot.prop.path value of state
     * @return {any}
     *
     * @example
     *
     * // Get the current state of analytics
     * analytics.getState()
     *
     * // Get a subpath of state
     * analytics.getState('context.offline')
     */
    getState: function getState(key) {
      var state = store.getState();
      if (key) return analyticsUtils.dotProp(state, key);
      return Object.assign({}, state);
    },

    /*
     * Emit events for other plugins or middleware to react to.
     * @param  {Object} action - event to dispatch
     */
    dispatch: function dispatch(action) {
      var actionData = analyticsUtils.isString(action) ? {
        type: action
      } : action;

      if (isReservedAction(actionData.type)) {
        throw new Error('reserved action ' + actionData.type);
      }

      var _private = action._ || {}; // Dispatch actionStart
      // const autoPrefixType = `${actionData.type.replace(/Start$/, '')}Start`


      var dispatchData = objectSpread2(objectSpread2({}, actionData), {}, {
        _: objectSpread2({
          originalAction: actionData.type
        }, _private) // type: `${autoPrefixType}`

      });

      store.dispatch(dispatchData);
    },
    // Do not use. Will be removed. Here for Backwards compatiblity.
    // Moved to analytics.plugins.enable
    enablePlugin: plugins.enable,
    /// Do not use. Will be removed. Here for Backwards compatiblity.
    /// Moved to analytics.plugins.disable
    disablePlugin: plugins.disable,
    // Do not use. Will be removed. Here for Backwards compatiblity.
    // New plugins api
    plugins: plugins,

    /**
     * Storage utilities for persisting data.
     * These methods will allow you to save data in localStorage, cookies, or to the window.
     * @typedef {Object} Storage
     * @property {GetItem} getItem - Get value from storage
     * @property {SetItem} setItem - Set storage value
     * @property {RemoveItem} removeItem - Remove storage value
     *
     * @example
     *
     * // Pull storage off analytics instance
     * const { storage } = analytics
     *
     * // Get value
     * storage.getItem('storage_key')
     *
     * // Set value
     * storage.setItem('storage_key', 'value')
     *
     * // Remove value
     * storage.removeItem('storage_key')
     */
    storage: {
      /**
       * Get value from storage
       * @typedef {Function} GetItem
       * @param {String} key - storage key
       * @param {Object} [options] - storage options
       * @return {Any}
       *
       * @example
       *
       * analytics.storage.getItem('storage_key')
       */
      getItem: storage.getItem,

      /**
       * Set storage value
       * @typedef {Function} SetItem
       * @param {String} key - storage key
       * @param {any} value - storage value
       * @param {Object} [options] - storage options
       *
       * @example
       *
       * analytics.storage.setItem('storage_key', 'value')
       */
      setItem: function setItem(key, value, options) {
        store.dispatch({
          type: EVENTS.setItemStart,
          key: key,
          value: value,
          options: options
        });
      },

      /**
       * Remove storage value
       * @typedef {Function} RemoveItem
       * @param {String} key - storage key
       * @param {Object} [options] - storage options
       *
       * @example
       *
       * analytics.storage.removeItem('storage_key')
       */
      removeItem: function removeItem(key, options) {
        store.dispatch({
          type: EVENTS.removeItemStart,
          key: key,
          options: options
        });
      }
    },

    /*
     * Set the anonymous ID of the visitor
     * @param {String} anonymousId - anonymous Id to set
     * @param {Object} [options] - storage options
     *
     * @example
     *
     * // Set anonymous ID
     * analytics.setAnonymousId('1234567')
     */
    setAnonymousId: function setAnonymousId(anonymousId, options) {
      /* sets temporary in memory id. Not to be relied on */
      // globalContext[tempKey(ANONID)] = anonymousId
      instance.storage.setItem(ANON_ID, anonymousId, options);
    },

    /*
     * Events exposed by core analytics library and all loaded plugins
     * @type {Array}
     */
    events: {
      all: allSystemEvents,
      core: coreEvents,
      plugins: allPluginEvents // byType: (type) => {} @Todo grab logic from engine and give inspectable events

    }
  };

  var enrichMiddleware = function enrichMiddleware(storeAPI) {
    return function (next) {
      return function (action) {
        if (!action.meta) {
          action.meta = generateMeta();
        }

        return next(action);
      };
    };
  };

  var middlewares = parsedOptions.middlewares.concat([enrichMiddleware,
  /* Core analytics middleware */
  dynamicMiddlewares(before), // Before dynamic middleware <-- fixed pageStart .on listener

  /* Plugin engine */
  pluginMiddleware(instance, getPlugins, {
    all: allSystemEvents,
    plugins: allPluginEvents
  }), storageMiddleware(storage), initializeMiddleware(instance), identifyMiddleware(instance, storage),
  /* after dynamic middleware */
  dynamicMiddlewares(after)]);
  /* Initial analytics state keys */

  var coreReducers = {
    context: context,
    user: userReducer(storage),
    page: page,
    track: trackReducer,
    plugins: createReducer(getPlugins),
    queue: queueReducer
  };
  var composeEnhancers = compose;
  var composeWithGlobalDebug = compose;

  if (analyticsUtils.inBrowser && config.debug) {
    var devTools = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__;

    if (devTools) {
      composeEnhancers = devTools({
        trace: true,
        traceLimit: 25
      });
    }

    composeWithGlobalDebug = function composeWithGlobalDebug() {
      if (arguments.length === 0) return Debug();
      if (analyticsUtils.isObject(_typeof_1(arguments[0]))) return composeWithDebug(arguments[0]);
      return composeWithDebug().apply(null, arguments);
    };
  }

  var initialConfig = makeContext(config);
  var intialPluginState = parsedOptions.pluginsArray.reduce(function (acc, plugin) {
    var name = plugin.name,
        config = plugin.config,
        loaded = plugin.loaded;
    var isEnabled = parsedOptions.pluginEnabled[name];
    acc[name] = {
      enabled: isEnabled,
      // If plugin enabled & has no initialize method, set initialized to true, else false
      initialized: isEnabled ? Boolean(!plugin.initialize) : false,
      loaded: Boolean(loaded()),
      config: config || {}
    };
    return acc;
  }, {});
  var initialState = {
    context: initialConfig,
    user: visitorInfo,
    plugins: intialPluginState // Todo allow for more userland defined initial state?

    /* Create analytics store! */

  };
  var store = createStore( // register reducers
  combineReducers(objectSpread2(objectSpread2({}, coreReducers), customReducers)), // set user defined initial state
  initialState, // register middleware & plugins used
  composeWithGlobalDebug(composeEnhancers(applyMiddleware.apply(void 0, toConsumableArray(middlewares)))));

  function enhanceDispatch(fn) {
    return function (event, resolver, callbacks) {
      // console.log('original event', event)
      var meta = generateMeta(event.meta, resolver, ensureArray(callbacks)); // if (resolver) console.log('dispatch resolver', resolver)
      // if (callbacks) console.log('dispatch callbacks', callbacks)

      var newEvent = objectSpread2(objectSpread2({}, event), {
        meta: meta
      }); // console.log('newEvent', newEvent)


      return fn.apply(null, [newEvent]);
    };
  } // Automatically apply meta to dispatch calls


  store.dispatch = enhanceDispatch(store.dispatch);
  /* Synchronously call bootstrap & register Plugin methods */

  var pluginKeys = Object.keys(customPlugins);
  /* Bootstrap analytic plugins */

  store.dispatch({
    type: EVENTS.bootstrap,
    plugins: pluginKeys,
    config: initialConfig,
    params: params,
    user: visitorInfo,
    persistedUser: persistedUser
  });
  var enabledPlugins = pluginKeys.filter(function (name) {
    return parsedOptions.pluginEnabled[name];
  });
  var disabledPlugins = pluginKeys.filter(function (name) {
    return !parsedOptions.pluginEnabled[name];
  });
  /* Register analytic plugins */

  store.dispatch({
    type: EVENTS.registerPlugins,
    plugins: pluginKeys,
    enabled: parsedOptions.pluginEnabled
  });
  /* dispatch register for individual plugins */

  parsedOptions.pluginsArray.map(function (plugin, i) {
    var bootstrap = plugin.bootstrap,
        config = plugin.config,
        name = plugin.name;

    if (bootstrap && analyticsUtils.isFunction(bootstrap)) {
      bootstrap({
        instance: instance,
        config: config,
        payload: plugin
      });
    }
    /* Register plugins */


    store.dispatch({
      type: EVENTS.registerPluginType(name),
      name: name,
      enabled: parsedOptions.pluginEnabled[name],
      plugin: plugin
    });
    /* All plugins registered initialize, is last loop */

    if (parsedOptions.pluginsArray.length === i + 1) {
      store.dispatch({
        type: EVENTS.initializeStart,
        plugins: enabledPlugins,
        disabled: disabledPlugins
      });
    }
  });

  {
    /* Watch for network events */
    watch(function (offline) {
      store.dispatch({
        type: offline ? EVENTS.offline : EVENTS.online
      });
    });
    /* Tick heartbeat for queued events */

    heartBeat(store, getPlugins, instance);
  }

  function appendArguments(fn) {
    return function () {
      var originalArgs = Array.prototype.slice.call(arguments); // Pass analytics instance as last arg for arrow functions

      var argsToPass = Array.apply(null, Array(fn.length)).map(function () {}).map(function (x, i) {
        if (originalArgs[i] || originalArgs[i] === false || originalArgs[i] === null) {
          return originalArgs[i];
        }
      }) // Add instance to args
      .concat(instance); // Set instance on extended methods

      return fn.apply({
        instance: instance
      }, argsToPass);
    };
  }
  /* Return analytics instance */


  return instance;
} // Duplicated strings


var before = 'before';
var after = 'after';

exports.default = analytics;
exports.init = analytics;
exports.Analytics = analytics;
exports.EVENTS = EVENTS;
exports.CONSTANTS = constants;

},{"analytics-utils":5}],3:[function(require,module,exports){
var n=[["add","attach"],["remove","detach"]];function r(r){if("undefined"!=typeof window){var e=r?n:n.reverse(),t=e[0],u=e[1],o=t[0]+"EventListener";return function(n,e,i,f){if(!n)throw new Error("Element not found");var a="on"+e,v=f||!1;if(n[o]){var c=function(){return n[o](e,i,v)};return c(),function(){return n[u[0]+"EventListener"](e,i,v),c}}if(n[t[1]]){var d=function(){return n[t[1]](a,i)};return d(),function(){return n[u[1]](a,i),d}}var s=function(){return n[a]=r?i:null};return s(),function(){return n[a]=r?null:i,s}}}}var e=r(!0),t=r();exports.addListener=e,exports.removeListener=t;


},{}],4:[function(require,module,exports){
(function (global){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var cookieUtils = require('@analytics/cookie-utils');

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function hasLocalStorage() {

  try {
    if (typeof localStorage === 'undefined' || typeof JSON === 'undefined') {
      return false;
    } // test for safari private


    localStorage.setItem('_t_', '1');
    localStorage.removeItem('_t_');
  } catch (err) {
    return false;
  }

  return true;
}

function parse(input) {
  var value;

  try {
    value = JSON.parse(input);

    if (typeof value === 'undefined') {
      value = input;
    }

    if (value === 'true') {
      value = true;
    }

    if (value === 'false') {
      value = false;
    }

    if (parseFloat(value) === value && _typeof(value) !== 'object') {
      value = parseFloat(value);
    }
  } catch (e) {
    value = input;
  }

  return value;
}

var globalContext = (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object' && self.self === self && self || (typeof global === "undefined" ? "undefined" : _typeof(global)) === 'object' && global.global === global && global || undefined;

var ALL = '*';
var LOCAL_STORAGE = 'localStorage';
var COOKIE = 'cookie';
var GLOBAL = 'global'; // Verify support

var hasStorage = hasLocalStorage();
var hasCookies = cookieUtils.hasCookieSupport();
/**
 * Get storage item from localStorage, cookie, or window
 * @param  {string} key - key of item to get
 * @param  {object|string} [options] - storage options. If string location of where to get storage
 * @param  {string} [options.storage] - Define type of storage to pull from.
 * @return {Any}  the value of key
 */

function getItem(key) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!key) return null;
  var storageType = getStorageType(options); // Get value from all locations

  if (storageType === ALL) return getAll(key);
  /* 1. Try localStorage */

  if (useLocal(storageType)) {
    var value = localStorage.getItem(key);
    if (value || storageType === LOCAL_STORAGE) return parse(value);
  }
  /* 2. Fallback to cookie */


  if (useCookie(storageType)) {
    var _value = cookieUtils.getCookie(key);

    if (_value || storageType === COOKIE) return parse(_value);
  }
  /* 3. Fallback to window/global. */


  return globalContext[key] || null;
}

function getAll(key) {
  return {
    cookie: parse(cookieUtils.getCookie(key)),
    localStorage: parse(localStorage.getItem(key)),
    global: globalContext[key] || null
  };
}
/**
 * Store values in localStorage, cookie, or window
 * @param {string} key - key of item to set
 * @param {*} value - value of item to set
 * @param {object|string} [options] - storage options. If string location of where to get storage
 * @param {string} [options.storage] - Define type of storage to pull from.
 * @returns {object} returns old value, new values, & location of storage
 */


function setItem(key, value) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!key || typeof value === 'undefined') {
    return;
  }

  var data = {};
  var storageType = getStorageType(options);
  var saveValue = JSON.stringify(value);
  var setAll = storageType === ALL;
  /* 1. Try localStorage */

  if (useLocal(storageType)) {
    // console.log('SET as localstorage', saveValue)
    var values = {
      current: value,
      previous: parse(localStorage.getItem(key)) // Set LocalStorage item

    };
    localStorage.setItem(key, saveValue);

    if (!setAll) {
      return _objectSpread2({
        location: LOCAL_STORAGE
      }, values);
    } // Set object


    data[LOCAL_STORAGE] = values;
  }
  /* 2. Fallback to cookie */


  if (useCookie(storageType)) {
    // console.log('SET as cookie', saveValue)
    var cookieValues = {
      current: value,
      previous: parse(cookieUtils.getCookie(key)) // Set Cookie

    };
    cookieUtils.setCookie(key, saveValue);

    if (!setAll) {
      return _objectSpread2({
        location: COOKIE
      }, cookieValues);
    } // Set object


    data[COOKIE] = cookieValues;
  }
  /* 3. Fallback to window/global */


  var globalValues = {
    current: value,
    previous: globalContext[key] // Set global value

  };
  globalContext[key] = value;

  if (!setAll) {
    return _objectSpread2({
      location: GLOBAL
    }, globalValues);
  } // Set object


  data[GLOBAL] = globalValues;
  return data;
}
/**
 * Remove values from localStorage, cookie, or window
 * @param {string} key - key of item to set
 * @param {object|string} [options] - storage options. If string location of where to get storage
 * @param {string} [options.storage] - Define type of storage to pull from.
 */

function removeItem(key) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!key) return false;
  var storageType = getStorageType(options);
  var removeAll = storageType === ALL;
  var locations = [];

  if (removeAll || useLocal(storageType)) {
    /* 1. Try localStorage */
    localStorage.removeItem(key);
    locations.push(LOCAL_STORAGE);
  }

  if (removeAll || useCookie(storageType)) {
    /* 2. Fallback to cookie */
    cookieUtils.removeCookie(key);
    locations.push(COOKIE);
  }
  /* 3. Fallback to window/global */


  if (removeAll || useGlobal(storageType)) {
    globalContext[key] = undefined;
    locations.push(GLOBAL);
  }

  return locations;
}

function getStorageType(options) {
  return typeof options === 'string' ? options : options.storage;
}

function useGlobal(storage) {
  return !storage || storage === GLOBAL;
}

function useLocal(storage) {
  // If has localStorage and storage option not defined, or is set to 'localStorage' or '*'
  return hasStorage && (!storage || storage === LOCAL_STORAGE || storage === ALL);
}

function useCookie(storage) {
  // If has cookies and storage option not defined, or is set to 'cookies' or '*'
  return hasCookies && (!storage || storage === COOKIE || storage === ALL);
}
var index = {
  getItem: getItem,
  setItem: setItem,
  removeItem: removeItem
};

exports.getCookie = cookieUtils.getCookie;
exports.setCookie = cookieUtils.setCookie;
exports.removeCookie = cookieUtils.removeCookie;
exports.hasCookieSupport = cookieUtils.hasCookieSupport;
exports.ALL = ALL;
exports.LOCAL_STORAGE = LOCAL_STORAGE;
exports.COOKIE = COOKIE;
exports.GLOBAL = GLOBAL;
exports.getItem = getItem;
exports.setItem = setItem;
exports.removeItem = removeItem;
exports.globalContext = globalContext;
exports.hasLocalStorageSupport = hasLocalStorage;
exports.default = index;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"@analytics/cookie-utils":1}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var dlv = _interopDefault(require('dlv'));
var storageUtils = require('@analytics/storage-utils');
var storageUtils__default = _interopDefault(storageUtils);

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function isFunction(x) {
  return typeof x === 'function';
}
/** 
 * @param x
 * @return {x is string}
 */

function isString(x) {
  return typeof x === 'string';
}
/** 
 * @param x
 * @return {x is undefined}
 */

function isUndefined(x) {
  return typeof x === 'undefined';
}
/** 
 * @param x
 * @return {x is boolean}
 */

function isBoolean(x) {
  return typeof x === 'boolean';
}
/** 
 * @template T
 * @param x
 * @return {x is Array<T>}
 */

function isArray(x) {
  return Array.isArray(x);
}
/** 
 * @param obj
 * @return {obj is Object}
 */

function isObject(obj) {
  if (_typeof(obj) !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

function decode(s) {
  try {
    return decodeURIComponent(s.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

var inBrowser = typeof document !== 'undefined';

/**
 * @returns {string | undefined}
 */

function getBrowserLocale() {
  if (!inBrowser) return;
  var _navigator = navigator,
      language = _navigator.language,
      languages = _navigator.languages,
      userLanguage = _navigator.userLanguage;
  if (userLanguage) return userLanguage; // IE only

  return languages && languages.length ? languages[0] : language;
}

function getTimeZone() {
  try {
    return Intl.DateTimeFormat().resolvedOptions().timeZone;
  } catch (error) {}
}

/**
 * @param {string | null | undefined} ref
 * @returns {boolean | undefined}
 */

function isExternalReferrer(ref) {
  if (!inBrowser) return false;
  var referrer = ref || document.referrer;

  if (referrer) {
    var port = window.document.location.port;
    var _ref = referrer.split('/')[2];

    if (port) {
      _ref = _ref.replace(":".concat(port), '');
    }

    return _ref !== window.location.hostname;
  }

  return false;
}

/**
 * Check if a script is loaded
 * @param  {String|RegExp} script - Script src as string or regex
 * @return {Boolean} is script loaded
 */

function isScriptLoaded(script) {
  if (!inBrowser) return true;
  var scripts = document.getElementsByTagName('script');
  return !!Object.keys(scripts).filter(function (key) {
    var src = scripts[key].src;

    if (typeof script === 'string') {
      return src.indexOf(script) !== -1;
    } else if (script instanceof RegExp) {
      return src.match(script);
    }

    return false;
  }).length;
}

function noOp() {}

function paramsClean(url, param) {
  var search = (url.split('?') || [,])[1]; // eslint-disable-line

  if (!search || search.indexOf(param) === -1) {
    return url;
  } // remove all utm params from URL search


  var regex = new RegExp("(\\&|\\?)".concat(param, "([_A-Za-z0-9\"+=.\\/\\-@%]+)"), 'g');
  var cleanSearch = "?".concat(search).replace(regex, '').replace(/^&/, '?'); // replace search params with clean params

  var cleanURL = url.replace("?".concat(search), cleanSearch); // use browser history API to clean the params

  return cleanURL;
}

/**
 * Get a given query parameter value
 * @param  {string} param - Key of parameter to find
 * @param  {string} url - url to search
 * @return {string} match
 */

function getValueParamValue(param, url) {
  return decode((RegExp("".concat(param, "=(.+?)(&|$)")).exec(url) || [, ''])[1]);
}

/**
 * Get search string from given url
 * @param  {string} [url] - optional url string. If no url, window.location.search will be used
 * @return {string} url search string
 */

function getSearchString(url) {
  if (url) {
    var p = url.match(/\?(.*)/);
    return p && p[1] ? p[1].split('#')[0] : '';
  }

  return inBrowser && window.location.search.substring(1);
}
/**
 * Parse url parameters into javascript object
 * @param  {string} [url] - URI to parse. If no url supplied window.location will be used
 * @return {object} parsed url parameters
 */


function paramsParse(url) {
  return getParamsAsObject(getSearchString(url));
}
/*
?first=abc&a[]=123&a[]=false&b[]=str&c[]=3.5&a[]=last
https://random.url.com?Target=Report&Method=getStats&fields%5B%5D=Offer.name&fields%5B%5D=Advertiser.company&fields%5B%5D=Stat.clicks&fields%5B%5D=Stat.conversions&fields%5B%5D=Stat.cpa&fields%5B%5D=Stat.payout&fields%5B%5D=Stat.date&fields%5B%5D=Stat.offer_id&fields%5B%5D=Affiliate.company&groups%5B%5D=Stat.offer_id&groups%5B%5D=Stat.date&filters%5BStat.affiliate_id%5D%5Bconditional%5D=EQUAL_TO&filters%5BStat.affiliate_id%5D%5Bvalues%5D=1831&limit=9999
https://random.url.com?Target=Offer&Method=findAll&filters%5Bhas_goals_enabled%5D%5BTRUE%5D=1&filters%5Bstatus%5D=active&fields%5B%5D=id&fields%5B%5D=name&fields%5B%5D=default_goal_name
http://localhost:3000/?Target=Offer&Method=findAll&filters[has_goals_enabled][TRUE]=1&filters[status]=active&filters[wow]arr[]=yaz&filters[wow]arr[]=naz&fields[]=id&fields[]=name&fields[]=default_goal_name */

function getParamsAsObject(query) {
  var params = {};
  var temp;
  var re = /([^&=]+)=?([^&]*)/g;

  while (temp = re.exec(query)) {
    var k = decode(temp[1]);
    var v = decode(temp[2]);

    if (k.substring(k.length - 2) === '[]') {
      k = k.substring(0, k.length - 2);
      (params[k] || (params[k] = [])).push(v);
    } else {
      params[k] = v === '' ? true : v;
    }
  }

  for (var prop in params) {
    var arr = prop.split('[');

    if (arr.length > 1) {
      assign(params, arr.map(function (x) {
        return x.replace(/[?[\]\\ ]/g, '');
      }), params[prop]);
      delete params[prop];
    }
  }

  return params;
}

function assign(obj, keyPath, value) {
  var lastKeyIndex = keyPath.length - 1;

  for (var i = 0; i < lastKeyIndex; ++i) {
    var key = keyPath[i];

    if (!(key in obj)) {
      obj[key] = {};
    }

    obj = obj[key];
  }

  obj[keyPath[lastKeyIndex]] = value;
}
/*
https://github.com/choojs/nanoquery/blob/791cbdfe49cc380f0b2f93477572128946171b46/browser.js
var reg = /([^?=&]+)(=([^&]*))?/g

function qs (url) {
  var obj = {}
  url.replace(/^.*\?/, '').replace(reg, function (a0, a1, a2, a3) {
    var value = decodeURIComponent(a3)
    var key = decodeURIComponent(a1)
    if (obj.hasOwnProperty(key)) {
      if (Array.isArray(obj[key])) obj[key].push(value)
      else obj[key] = [obj[key], value]
    } else {
      obj[key] = value
    }
  })
  return obj
}
*/

/**
 * Removes params from url in browser
 * @param  {string}   param       - param key to remove from current URL
 * @param  {() => void} [callback]  - callback function to run. Only runs in browser
 * @return {PromiseLike<void>}
 */

function paramsRemove(param, callback) {
  if (!inBrowser) return Promise.resolve();
  return new Promise(function (resolve, reject) {
    if (window.history && window.history.replaceState) {
      var url = window.location.href;
      var cleanUrl = paramsClean(url, param);

      if (url !== cleanUrl) {
        /* replace URL with history API */
        // eslint-disable-next-line no-restricted-globals
        history.replaceState({}, '', cleanUrl);
      }
    }

    if (callback) callback();
    return resolve();
  });
}

/**
 * Get host domain of url
 * @param  {String} url - href of page
 * @return {String} hostname of page
 *
 * @example
 *  getDomainHost('https://subdomain.my-site.com/')
 *  > subdomain.my-site.com
 */

function getDomainHost(url) {
  if (!inBrowser) return null;
  var a = document.createElement('a');
  a.setAttribute('href', url);
  return a.hostname;
}
/**
 * Get host domain of url
 * @param  {String} url - href of page
 * @return {String} base hostname of page
 *
 * @example
 *  getDomainBase('https://subdomain.my-site.com/')
 *  > my-site.com
 */

function getDomainBase(url) {
  var host = getDomainHost(url) || '';
  return host.split('.').slice(-2).join('.');
}
/**
 * Remove TLD from domain string
 * @param  {String} baseDomain - host name of site
 * @return {String}
 * @example
 *  trimTld('google.com')
 *  > google
 */

function trimTld(baseDomain) {
  var arr = baseDomain.split('.');
  return arr.length > 1 ? arr.slice(0, -1).join('.') : baseDomain;
}
var url = {
  trimTld: trimTld,
  getDomainBase: getDomainBase,
  getDomainHost: getDomainHost
};

var googleKey = 'google';
/**
 * @typedef {{
 *  campaign: string,
 *  referrer?: string,
 * } & DomainObject & Object.<string, any>} ReferrerObject
 */

/**
 * Checks a given url and parses referrer data
 * @param  {String} [referrer] - (optional) referring URL
 * @param  {String} [currentUrl] - (optional) the current url
 * @return {ReferrerObject}     [description]
 */

function parseReferrer(referrer, currentUrl) {
  if (!inBrowser) return false; // default referral data

  var refData = {
    'source': '(direct)',
    'medium': '(none)',
    'campaign': '(not set)' // Add raw ref url if external

  };

  if (referrer && isExternalReferrer(referrer)) {
    refData.referrer = referrer;
  }

  var domainInfo = parseDomain(referrer); // Read referrer URI and infer source

  if (domainInfo && Object.keys(domainInfo).length) {
    refData = Object.assign({}, refData, domainInfo);
  } // Read URI params and use set utm params


  var params = paramsParse(currentUrl);
  var paramKeys = Object.keys(params);

  if (!paramKeys.length) {
    return refData;
  } // set campaign params off GA matches


  var gaParams = paramKeys.reduce(function (acc, key) {
    // match utm params & dclid (display) & gclid (cpc)
    if (key.match(/^utm_/)) {
      acc["".concat(key.replace(/^utm_/, ''))] = params[key];
    } // https://developers.google.com/analytics/devguides/collection/protocol/v1/parameters
    // dclid - cpc Cost-Per-Thousand Impressions
    // gclid - cpc Cost per Click


    if (key.match(/^(d|g)clid/)) {
      acc['source'] = googleKey;
      acc['medium'] = params.gclid ? 'cpc' : 'cpm';
      acc[key] = params[key];
    }

    return acc;
  }, {});
  return Object.assign({}, refData, gaParams);
}
/**
 * @typedef {{
 *  source: string,
 *  medium: string,
 *  term?: string
 * }} DomainObject
 */

/**
 * Client side domain parser for determining marketing data.
 * @param  {String} referrer - ref url
 * @return {DomainObject | boolean}
 */

function parseDomain(referrer) {
  if (!referrer || !inBrowser) return false;
  var referringDomain = getDomainBase(referrer);
  var a = document.createElement('a');
  a.href = referrer; // Shim for the billion google search engines

  if (a.hostname.indexOf(googleKey) > -1) {
    referringDomain = googleKey;
  } // If is search engine


  if (searchEngines[referringDomain]) {
    var searchEngine = searchEngines[referringDomain];
    var queryParam = typeof searchEngine === 'string' ? searchEngine : searchEngine.p;
    var termRegex = new RegExp(queryParam + '=.*?([^&#]*|$)', 'gi');
    var term = a.search.match(termRegex);
    return {
      source: searchEngine.n || trimTld(referringDomain),
      medium: 'organic',
      term: (term ? term[0].split('=')[1] : '') || '(not provided)'
    };
  } // Default


  var medium = !isExternalReferrer(referrer) ? 'internal' : 'referral';
  return {
    source: a.hostname,
    medium: medium
  };
}
/**
 * Search engine query string data
 * @type {Object}
 */


var Q = 'q';
var QUERY = 'query';
var searchEngines = {
  'daum.net': Q,
  'eniro.se': 'search_word',
  'naver.com': QUERY,
  'yahoo.com': 'p',
  'msn.com': Q,
  'aol.com': Q,
  'ask.com': Q,
  'baidu.com': 'wd',
  'yandex.com': 'text',
  'rambler.ru': 'words',
  'google': Q,
  'bing.com': {
    'p': Q,
    'n': 'live'
  }
};

/**
 * @return {string}
 */
function uuid() {
  var u = '',
      m = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx',
      i = 0,
      rb = Math.random() * 0xffffffff | 0;

  while (i++ < 36) {
    var c = m[i - 1],
        r = rb & 0xf,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    u += c == '-' || c == '4' ? c : v.toString(16);
    rb = i % 8 == 0 ? Math.random() * 0xffffffff | 0 : rb >> 4;
  }

  return u;
}

function throttle(func, wait) {
  var context, args, result;
  var timeout = null;
  var previous = 0;

  var later = function later() {
    previous = new Date();
    timeout = null;
    result = func.apply(context, args);
  };

  return function () {
    var now = new Date();

    if (!previous) {
      previous = now;
    }

    var remaining = wait - (now - previous);
    context = this;
    args = arguments;

    if (remaining <= 0) {
      clearTimeout(timeout);
      timeout = null;
      previous = now;
      result = func.apply(context, args);
    } else if (!timeout) {
      timeout = setTimeout(later, remaining);
    }

    return result;
  };
}

exports.dotProp = dlv;
exports.storage = storageUtils__default;
exports.getCookie = storageUtils.getCookie;
exports.setCookie = storageUtils.setCookie;
exports.globalContext = storageUtils.globalContext;
exports.removeCookie = storageUtils.removeCookie;
exports.isFunction = isFunction;
exports.isString = isString;
exports.isArray = isArray;
exports.isObject = isObject;
exports.isUndefined = isUndefined;
exports.isBoolean = isBoolean;
exports.decodeUri = decode;
exports.getBrowserLocale = getBrowserLocale;
exports.getTimeZone = getTimeZone;
exports.inBrowser = inBrowser;
exports.isExternalReferrer = isExternalReferrer;
exports.isScriptLoaded = isScriptLoaded;
exports.noOp = noOp;
exports.paramsClean = paramsClean;
exports.paramsGet = getValueParamValue;
exports.paramsParse = paramsParse;
exports.paramsRemove = paramsRemove;
exports.parseReferrer = parseReferrer;
exports.url = url;
exports.uuid = uuid;
exports.throttle = throttle;

},{"@analytics/storage-utils":4,"dlv":34}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var analytics = require('@analytics/core');
var analytics__default = _interopDefault(analytics);
var storage = _interopDefault(require('@analytics/storage-utils'));

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty;

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var objectSpread2 = _objectSpread2;

function analyticsLib() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaultSettings = {
    storage: storage
  };
  return analytics__default(objectSpread2(objectSpread2({}, defaultSettings), opts));
}

exports.EVENTS = analytics.EVENTS;
exports.CONSTANTS = analytics.CONSTANTS;
exports.default = analyticsLib;
exports.init = analyticsLib;
exports.Analytics = analyticsLib;

},{"@analytics/core":2,"@analytics/storage-utils":4}],7:[function(require,module,exports){
module.exports = require('./lib/axios');
},{"./lib/axios":9}],8:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var cookies = require('./../helpers/cookies');
var buildURL = require('./../helpers/buildURL');
var buildFullPath = require('../core/buildFullPath');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var createError = require('../core/createError');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

},{"../core/buildFullPath":15,"../core/createError":16,"./../core/settle":20,"./../helpers/buildURL":24,"./../helpers/cookies":26,"./../helpers/isURLSameOrigin":29,"./../helpers/parseHeaders":31,"./../utils":33}],9:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

// Expose isAxiosError
axios.isAxiosError = require('./helpers/isAxiosError');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"./cancel/Cancel":10,"./cancel/CancelToken":11,"./cancel/isCancel":12,"./core/Axios":13,"./core/mergeConfig":19,"./defaults":22,"./helpers/bind":23,"./helpers/isAxiosError":28,"./helpers/spread":32,"./utils":33}],10:[function(require,module,exports){
'use strict';

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

},{}],11:[function(require,module,exports){
'use strict';

var Cancel = require('./Cancel');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./Cancel":10}],12:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],13:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

},{"../helpers/buildURL":24,"./../utils":33,"./InterceptorManager":14,"./dispatchRequest":17,"./mergeConfig":19}],14:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":33}],15:[function(require,module,exports){
'use strict';

var isAbsoluteURL = require('../helpers/isAbsoluteURL');
var combineURLs = require('../helpers/combineURLs');

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

},{"../helpers/combineURLs":25,"../helpers/isAbsoluteURL":27}],16:[function(require,module,exports){
'use strict';

var enhanceError = require('./enhanceError');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":18}],17:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/isCancel":12,"../defaults":22,"./../utils":33,"./transformData":21}],18:[function(require,module,exports){
'use strict';

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};

},{}],19:[function(require,module,exports){
'use strict';

var utils = require('../utils');

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};

},{"../utils":33}],20:[function(require,module,exports){
'use strict';

var createError = require('./createError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};

},{"./createError":16}],21:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

},{"./../utils":33}],22:[function(require,module,exports){
(function (process){(function (){
'use strict';

var utils = require('./utils');
var normalizeHeaderName = require('./helpers/normalizeHeaderName');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this)}).call(this,require('_process'))
},{"./adapters/http":8,"./adapters/xhr":8,"./helpers/normalizeHeaderName":30,"./utils":33,"_process":35}],23:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

},{}],24:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":33}],25:[function(require,module,exports){
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

},{}],26:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);

},{"./../utils":33}],27:[function(require,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

},{}],28:[function(require,module,exports){
'use strict';

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};

},{}],29:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);

},{"./../utils":33}],30:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":33}],31:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

},{"./../utils":33}],32:[function(require,module,exports){
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],33:[function(require,module,exports){
'use strict';

var bind = require('./helpers/bind');

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

},{"./helpers/bind":23}],34:[function(require,module,exports){
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=function(t,n,e,i,o){for(n=n.split?n.split("."):n,i=0;i<n.length;i++)t=t?t[n[i]]:o;return t===o?e:t}:"function"==typeof define&&define.amd?define(function(){return function(t,n,e,i,o){for(n=n.split?n.split("."):n,i=0;i<n.length;i++)t=t?t[n[i]]:o;return t===o?e:t}}):t.dlv=function(t,n,e,i,o){for(n=n.split?n.split("."):n,i=0;i<n.length;i++)t=t?t[n[i]]:o;return t===o?e:t}}(this);


},{}],35:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./nil.js":38,"./parse.js":39,"./stringify.js":43,"./v1.js":44,"./v3.js":45,"./v4.js":47,"./v5.js":48,"./validate.js":49,"./version.js":50}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
},{}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;
},{}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;
},{"./validate.js":49}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;
},{}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
},{}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
},{}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;
},{"./validate.js":49}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports.default = _default;
},{"./rng.js":41,"./stringify.js":43}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
},{"./md5.js":37,"./v35.js":46}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
},{"./parse.js":39,"./stringify.js":43}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports.default = _default;
},{"./rng.js":41,"./stringify.js":43}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
},{"./sha1.js":42,"./v35.js":46}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
},{"./regex.js":40}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports.default = _default;
},{"./validate.js":49}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.request = request;

var _axios = require("axios");

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function request(_ref) {
    var url = _ref.url,
        header = _ref.header,
        method = _ref.method,
        data = _ref.data;


    if (typeof header == "undefined") {
        header = { "Content-Type": 'application/json' };
    }

    if (typeof method == "undefined") {
        method = "get";
    }

    var response = await (0, _axios2.default)({
        url: url,
        method: method,
        header: header,
        data: data
    });

    return response;
};

},{"axios":7}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = ClientInfo;
function ClientInfo() {

    var getReferer = function getReferer() {

        var referrerURL = document.referrer;
        if (referrerURL) {
            // parse referrer URL
            var referrer = document.createElement('a');
            referrer.href = referrerURL;

            // only process referrer if it's not coming from the same site as the current page
            var local = document.createElement('a');
            local.href = document.URL;
            if (referrer.host !== local.host) {
                // get search element if it exists and extract search query if available
                var search = referrer.search;
                var query = undefined;
                if (search && search !== '') {
                    // parse parameters
                    var queryParams = [],
                        param = void 0;
                    var queryParamPairs = search.slice(1).split('&');
                    for (var i = 0; i < queryParamPairs.length; i++) {
                        param = queryParamPairs[i].split('=');
                        queryParams.push(param[0]);
                        queryParams[param[0]] = param[1];
                    }

                    // try to extract query: q is Google-like (most search engines), p is Yahoo
                    query = queryParams.q || queryParams.p;
                    query = decodeURIComponent(query).replace(/\+/g, ' ');
                }

                return {
                    host: referrer.host,
                    query: query
                };
            }
        }
        return {
            host: null,
            query: null
        };
    };

    return {

        time: function time() {
            return {
                local: new Date().toLocaleString(),
                tz: Intl.DateTimeFormat().resolvedOptions().timeZone
            };
        },

        page: function page() {
            return {
                url: location.href,
                path: location.pathname,
                hash: location.hash,
                title: document.title,
                referer: getReferer(),
                history: {
                    length: history.length
                }
            };
        },

        screen: function (_screen) {
            function screen() {
                return _screen.apply(this, arguments);
            }

            screen.toString = function () {
                return _screen.toString();
            };

            return screen;
        }(function () {
            return {
                width: screen.width,
                height: screen.height,
                innerWidth: innerWidth,
                innerHeight: innerHeight,
                availWidth: screen.availWidth,
                availHeight: screen.availHeight,
                colorDepth: screen.colorDepth,
                pixelDepth: screen.pixelDepth
            };
        }),

        browser: function browser() {
            if (typeof navigator !== "undefined") {
                var browserInfo = {
                    browser: {
                        name: navigator.appName,
                        engine: navigator.product,
                        appVersion: navigator.appVersion,
                        userAgent: navigator.userAgent,
                        language: navigator.language,
                        onLine: navigator.onLine,
                        javaEnabled: navigator.javaEnabled(),
                        cookieEnabled: navigator.cookieEnabled
                    },
                    device: {
                        platform: navigator.platform
                    }
                };
                return browserInfo;
            }
            return {};
        },

        storage: function storage() {
            return {
                local: localStorage,
                cookie: {
                    cookies1: document.cookie,
                    cookies2: decodeURIComponent(document.cookie.split(";"))
                }
            };
        }
    };
}

},{}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = Event;
function Event() {
    return {
        build: function build(_ref) {
            var type = _ref.type,
                source = _ref.source,
                metadata = _ref.metadata,
                session = _ref.session,
                profile = _ref.profile,
                context = _ref.context,
                properties = _ref.properties,
                user = _ref.user,
                options = _ref.options;

            return {
                type: type,
                // metadata: metadata,
                session: session,
                profile: profile,
                context: context,
                properties: properties,
                user: user,
                source: source,
                options: options
            };
        },
        dynamic: function dynamic(data) {
            return {
                properties: data.properties,
                type: data.type,
                user: data.user,
                options: data.options
            };
        },
        static: function _static(payload) {
            return {
                metadata: payload.metadata,
                source: payload.source,
                context: payload.context,
                profile: payload.profile,
                session: payload.session
            };
        }
    };
}

},{}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = EventsList;

var _event = require("./event");

var _event2 = _interopRequireDefault(_event);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function EventsList(container, profile) {

    var eventObject = (0, _event2.default)();
    if (container !== null) {
        container.events || (container.events = null);
    }

    return {

        add: function add(payload) {
            if (container !== null) {
                // Multiple
                if (container.events === null) {
                    container = eventObject.static(payload);
                    container.options = profile.context;
                    container.events = [];
                }
                container.events.push(eventObject.dynamic(payload));
            } else {
                console.error("[Trackardi] Missing container in EventsList.");
            }
        },
        get: function get() {
            return container;
        },

        reset: function reset() {
            container = { events: null };
        }
    };
}

},{"./event":53}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _analytics = require('analytics');

var _analytics2 = _interopRequireDefault(_analytics);

var _tracardi = require('./tracardi');

var _tracardi2 = _interopRequireDefault(_tracardi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var analytics = (0, _analytics2.default)({
    app: 'tracardi',
    debug: true,
    plugins: [(0, _tracardi2.default)(options)]
});

exports.default = analytics;

},{"./tracardi":56,"analytics":6}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = tracardiPlugin;

var _cookieUtils = require('@analytics/cookie-utils');

var _uuid = require('uuid');

var _event = require('./domain/event');

var _event2 = _interopRequireDefault(_event);

var _clientInfo = require('./domain/clientInfo');

var _clientInfo2 = _interopRequireDefault(_clientInfo);

var _eventsList = require('./domain/eventsList');

var _eventsList2 = _interopRequireDefault(_eventsList);

var _storageUtils = require('@analytics/storage-utils');

var _apiCall = require('./apiCall');

var _listenerUtils = require('@analytics/listener-utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import loadJS from "./utils/loadJs";

function tracardiPlugin(options) {

    var clientInfo = (0, _clientInfo2.default)();
    var event = (0, _event2.default)();

    var isCookieSet = true;
    var trackEventList = (0, _eventsList2.default)({}, window.response);
    var immediateTrackEventList = (0, _eventsList2.default)({}, window.response);
    var cookieName = 'tracardi-session-id';
    var profileName = 'tracardi-profile-id';
    var consentKey = 'tracardi-consent-id';
    var profileId = (0, _storageUtils.getItem)(profileName);
    var sessionId = (0, _cookieUtils.getCookie)(cookieName);
    if (!sessionId) {
        sessionId = (0, _uuid.v4)();
        var expires = 0;
        (0, _cookieUtils.setCookie)(cookieName, sessionId, expires);
        isCookieSet = false;
    }
    var singleApiCall = {};

    var getEventPayload = function getEventPayload(payload) {
        var eventPayload = {
            type: payload.event,
            source: config.tracker.source,
            session: { id: sessionId },
            profile: profileId != null ? { id: profileId } : null,
            context: {
                time: clientInfo.time(),
                page: clientInfo.page(),
                browser: clientInfo.browser(),
                storage: clientInfo.storage(),
                screen: clientInfo.screen()
            },
            properties: payload.properties
        };

        if (payload.userId) {
            eventPayload['user'] = { id: payload.userId };
        }

        if (payload.options) {
            eventPayload['options'] = payload.options;
        }

        return eventPayload;
    };

    var handleError = function handleError(e) {
        if (e.response) {
            if (_typeof(e.response.data) === 'object') {
                console.error("[Tracker] " + e.response.data.detail);
            } else {
                console.error("[Tracker] " + e.message);
            }
        } else {
            console.error("[Tracker] " + e.message);
        }
    };

    var push = async function push(config) {

        try {

            var response = await (0, _apiCall.request)({
                method: "POST",
                url: config.tracker.url.api + '/track',
                data: trackEventList.get()
            });

            // If browser profile is the same as context profile then consent displayed
            // Consent is displayed when there is new profile created.

            if (typeof response.data.profile.id === "undefined") {
                console.error("[Tracardi] /track must return profile id. No profile id returned.");
            }

            var isConsentGiven = (0, _storageUtils.getItem)(consentKey) === response.data.profile.id;

            // Set profile id
            profileId = response.data.profile.id;
            (0, _storageUtils.setItem)(profileName, profileId);

            documentReady(function () {

                if (typeof config.listeners === "undefined") {
                    return;
                }

                // onContextReady event
                if (typeof config.listeners.onContextReady !== "undefined") {
                    var onContextReady = config.listeners.onContextReady;

                    if (typeof onContextReady !== "function") {
                        throw new TypeError("onContextReady must be a function.");
                    }

                    // loadJS(
                    //     "src/test.js",
                    //     ()=>{typeof main === "function" && main(response.data)},
                    //     document.body,
                    //     'script'
                    // )

                    onContextReady({
                        context: response.data,
                        tracker: window.tracardi.default,
                        helpers: window.tracardi.default.plugins.tracardi
                    });
                }

                // onConsentRequired
                if (typeof response.data.source.consent !== "undefined" && response.data.source.consent !== null) {
                    if (response.data.source.consent === true && !isConsentGiven) {
                        if (typeof config.listeners.onConsentRequired !== "undefined") {
                            var onConsentRequired = config.listeners.onConsentRequired;

                            if (typeof onConsentRequired !== "function") {
                                throw new TypeError("onConsentRequired must be a function.");
                            }

                            onConsentRequired({
                                context: response.data,
                                tracker: window.tracardi.default
                            });
                        }
                    }
                }
            });

            trackEventList.reset();
        } catch (e) {
            handleError(e);
        }
    };

    return {
        name: 'tracardi',

        config: {
            tracker: options.tracker,
            listeners: options.listeners
        },
        methods: {
            track: async function track(eventType, payload) {

                try {

                    payload = {
                        event: eventType,
                        properties: payload ? payload : {}
                    };

                    var eventPayload = getEventPayload(payload);

                    var trackerPayload = event.static(eventPayload);
                    trackerPayload.options = window.response.context;
                    trackerPayload.events = [event.dynamic(eventPayload)];

                    var response = await (0, _apiCall.request)({
                        method: "POST",
                        url: config.tracker.url.api + '/track',
                        data: trackerPayload
                    });

                    return response;
                } catch (e) {
                    return null;
                }
            },

            onClick: function onClick(object, func) {
                return (0, _listenerUtils.addListener)(object, 'click', func);
            },
            addListener: function addListener(object, event, func) {
                return (0, _listenerUtils.addListener)(object, event, func);
            },
            consentSubmitted: function consentSubmitted() {
                (0, _storageUtils.setItem)(consentKey, profileId);
            }
        },

        initializeStart: function initializeStart(_ref) {
            var abort = _ref.abort,
                config = _ref.config;


            if (typeof config === "undefined") {
                console.error(" because config is undefined.");
                return abort('Cancel the initialize call because of config is undefined.');
            }

            if (typeof config.tracker == 'undefined') {
                console.error("[Tracker] Tracker init stopped because config.tracker is undefined.");
                return abort('Cancel the initialize call because of config.tracker.source is undefined.');
            }

            if (typeof config.tracker.source === 'undefined') {
                console.error("[Tracker] Tracker init stopped because config.tracker.source is undefined.");
                return abort('Cancel the initialize call because of config.tracker.source is undefined.');
            }

            if (typeof config.tracker.url === "undefined") {
                console.error("[Tracker] Tracker init stopped because config.tracker.url is undefined.");
                return abort('Cancel the initialize call because of config.tracker.url is undefined.');
            }

            if (typeof config.tracker.url.api === "undefined") {
                console.error("[Tracker] Tracker init stopped because config.tracker.url.api is undefined.");
                return abort('Cancel the initialize call because of config.tracker.url.api s undefined.');
            }
        },

        initialize: function initialize(_ref2) {
            var config = _ref2.config;


            console.debug("[Tracker] Plugin init", config);

            singleApiCall = {
                tracks: false
            };

            if (!(0, _cookieUtils.hasCookieSupport)()) {
                console.error("[Tracker] Cookies disabled.");
                if (typeof config.listeners.onCookiesDisabled !== "undefined") {
                    var onCookiesDisabled = config.listeners.onCookiesDisabled;

                    if (typeof onCookiesDisabled !== "function") {
                        throw new TypeError("onSessionSet must be a function.");
                    }

                    onCookiesDisabled({
                        tracker: window.tracardi.default,
                        helpers: window.tracardi.default.plugins.tracardi
                    });
                }
                return;
            }

            // onSessionSet event
            if (!isCookieSet && typeof config.listeners.onSessionSet !== "undefined") {
                var onSessionSet = config.listeners.onSessionSet;

                if (typeof onSessionSet !== "function") {
                    throw new TypeError("onSessionSet must be a function.");
                }

                onSessionSet({
                    session: { id: sessionId },
                    tracker: window.tracardi.default,
                    helpers: window.tracardi.default.plugins.tracardi
                });
            }

            if (typeof config.listeners.onInit !== "undefined") {
                var onInit = config.listeners.onInit;
                if (typeof onInit !== "function") {
                    throw new TypeError("onInit must be a function.");
                }

                onInit({
                    session: { id: sessionId },
                    tracker: window.tracardi.default,
                    helpers: window.tracardi.default.plugins.tracardi
                });
            }

            window.config = config;
        },

        track: function track(_ref3) {
            var payload = _ref3.payload;


            if (typeof config == 'undefined' || typeof config.tracker == 'undefined' || typeof config.tracker.source === 'undefined') {
                console.error("[Tracker] config.tracker.source undefined.");
                return;
            }

            console.debug("[Tracker] Event track", payload);

            var eventPayload = getEventPayload(payload);

            if (typeof payload.options.fire !== "undefined" && payload.options.fire) {
                try {
                    immediateTrackEventList.add(event.build(eventPayload));
                    var response = (0, _apiCall.request)({
                        method: "POST",
                        url: config.tracker.url.api + '/track',
                        data: immediateTrackEventList.get()
                    });
                    console.warn("[Tracardi] Tracking with option `fire: true` will not trigger listeners such as onContextReady, onConsentRequired, etc.");

                    immediateTrackEventList.reset();
                    return response;
                } catch (e) {
                    handleError(e);
                }
            } else {
                trackEventList.add(event.build(eventPayload));
            }
        },

        trackEnd: function trackEnd(_ref4) {
            var config = _ref4.config;

            if (!singleApiCall.tracks) {
                singleApiCall.tracks = true;

                console.debug('[Tracker] TrackEnd');

                push(config);
            }
        },

        loaded: function loaded() {
            // return boolean so analytics knows when it can send data to third party
            return !!window.tracardi;
        }
    };
}

},{"./apiCall":51,"./domain/clientInfo":52,"./domain/event":53,"./domain/eventsList":54,"@analytics/cookie-utils":1,"@analytics/listener-utils":3,"@analytics/storage-utils":4,"uuid":36}]},{},[55])(55)
});
